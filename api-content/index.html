{"posts":[{"title":"几种屏幕尺寸对应的iPhone型号","content":"6.7英寸的iPhone 6.7英寸的屏幕是在iPhone 12 Pro Max引入的，此后的几代高端Max模型也继续使用这个屏幕尺寸。 iPhone 12 Pro Max (2020年发布) iPhone 13 Pro Max (2021年发布) iPhone 14 Pro Max (2022年发布) 6.5英寸的iPhone 6.5英寸的屏幕首次出现在iPhone XS Max上，后来iPhone 11 Pro Max也采用了这种尺寸。 iPhone XS Max (2018年发布) iPhone 11 Pro Max (2019年发布) 5.5英寸的iPhone 5.5英寸的屏幕在苹果的Plus系列中出现过。 iPhone 6 Plus (2014年发布) iPhone 6s Plus (2015年发布) iPhone 7 Plus (2016年发布) iPhone 8 Plus (2017年发布) ","link":"https://blog.xioayee.top/post/ji-chong-ping-mu-chi-cun-dui-ying-de-iphone-xing-hao/"},{"title":"SwiftUI如何滚动到指定的位置","content":"在 SwiftUI 中，实现 ScrollView 滚动到底部的功能，需要一些额外的步骤，因为 SwiftUI 的 ScrollView 默认并不提供直接的滚动控制。可以通过使用 ScrollViewReader 来实现这个功能。ScrollViewReader 提供了一个环境，其中可以使用其 proxy 对象来操作滚动视图的位置。 ScrollViewReader { scrollViewProxy in ScrollView { VStack { Button(action: { ... }, label: { ... }) .... Button(action: { ... }, label: { ... }) } } } 如上面代码所示，如果需要滚动到底部的Button，只需要给底部Button加个id属性，如： Button(action: { ... }, label: { ... }) .id(&quot;lastButton&quot;) 然后就可以使用 scrollViewProxy.scrollTo(&quot;lastButton&quot;, anchor: .bottom) 将ScrollView滚动到底部了，也可以给他加个动画： withAnimation { scrollViewProxy.scrollTo(&quot;lastButton&quot;, anchor: .bottom) } ","link":"https://blog.xioayee.top/post/swiftui-ru-he-gun-dong-dao-zhi-ding-de-wei-zhi/"},{"title":"让MongoDB支持事务","content":"从MongoDB v4.0开始已经支持事务了，可以用下面代码写事务操作： const session = db.getMongo().startSession(); session.startTransaction(); try { // 你的数据库操作 session.commitTransaction(); } catch (error) { console.error(&quot;Transaction failed: &quot;, error); session.abortTransaction(); } finally { session.endSession(); } 但是如果MongoDB没有配置副本集，就会报下面这个错误： Transaction numbers are only allowed on a replica set member or mongos 需要修改mongod.conf文件，加入下面配置： replication: replSetName: &quot;rs0&quot; 如果服务还在运行，先关闭服务。 首先，可以使用 ps 命令找到 MongoDB 进程的 PID： ps aux | grep mongod 找到 MongoDB 进程后，使用 kill 命令停止它： kill [PID] 然后，重新通过 mongod 命令启动 MongoDB mongod --config /usr/local/etc/mongod.conf 连接到 MongoDB shell 并初始化副本集： mongo rs.initiate() ","link":"https://blog.xioayee.top/post/rang-mongodb-zhi-chi-shi-wu/"},{"title":"SwiftUI教程","content":"先写了份SwiftUI学习教程大纲，涵盖了SwiftUI的所有关键技术和概念，后面有时间慢慢补坑。 SwiftUI基础 SwiftUI简介 声明式UI编程模型 Views 和 ViewBuilders 预览面板(Preview)的使用 常用控件及布局 Text, Image, Button等基础控件 Stacks(HStack, VStack, ZStack)布局 List 和 ScrollView LazyVGrid 和 LazyHGrid 网格布局 Form 表单 Spacer 和 Divider Combine框架基础 Publisher和Subscriber @Published和CurrentValueSubject Combine中的数据流和操作符 状态与数据流 @State 管理局部状态 @Binding 数据双向绑定 @ObservedObject 和 @StateObject @EnvironmentObject 环境对象 @Published 发布属性 页面导航 NavigationView 和 NavigationLink TabView 标签导航 Sheet 和 fullScreenCover 模态页面 Alerts 和 Actionsheets 生命周期和事件 onAppear 和 onDisappear onChange 监听状态变化 @Environment 获取环境值 动画与过渡 Animation 基础动画 过渡动画(transitions) 非对称过渡 matchedGeometryEffect 动画 手势交互 TapGesture 点击手势 LongPressGesture 长按手势 DragGesture 拖动手势 MagnificationGesture 缩放手势 RotationGesture 旋转手势 组合手势(simultaneously, sequenced) 自定义布局 自定义UIViewRepresentable 自定义Layout 数据持久化 @AppStorage 轻量数据持久化 Core Data 集成 与UIKit集成 UIViewControllerRepresentable UIViewRepresentable 绘图与特效 Paths &amp; Shapes绘图 UIGraphicsImageRenderer绘制 Core Image 滤镜 Metal 渲染 并发编程 async/await异步编程 Actor模型 TaskGroup 和 TaskPriority 辅助功能 动态字体缩放 色盲模式适配 辅助功能标签(accessibilityLabel) SwiftUI 3.0+ 新特性 AttributeGraph 自定义控件 Canvas 绘图 异步图片加载(AsyncImage) Tab 视图样式定制 DatePicker、Gauge等新控件 材料(Material)与模糊特效 ShareLink 分享页面 NavigationStack 和 NavigationSplitView 新页面导航方式 Charts 图表绘制 新的导航栏隐藏方式(toolbar/.hidden) SwiftUI最佳实践 架构模式：MVVM在SwiftUI中的应用 代码组织和模块化 可维护性和可测试性 实战项目 实战项目1: 待办事项应用 设计UI 数据模型 增删改查操作 状态管理 实战项目2: 天气应用 网络请求 JSON解析 异步图片加载 复杂布局 实战项目3: 新闻阅读器 RSS解析 多源合并 文章阅读视图 收藏与分享功能 ","link":"https://blog.xioayee.top/post/swiftui-jiao-cheng/"},{"title":"Combine里面类似flatMapLatest的操作方法","content":"在 Combine 框架中，并没有一个名为 flatMapLatest 的直接操作符，这是 ReactiveX（例如 RxSwift）中的一个术语，用于描述一个特定的 flatMap 行为：每当源发布者发出一个新的值，flatMapLatest 会切换到新的发布者，并取消订阅之前的发布者。 在 Combine 中，要实现 flatMapLatest 的行为，可以使用 map 和 switchToLatest 操作符结合起来。switchToLatest 是 Combine 提供的操作符，用于只接收最新发布者发出的值，忽略旧的发布者的值。 以下是一个示例，演示如何模拟 flatMapLatest 的行为： var cancellables = Set&lt;AnyCancellable&gt;() // 返回 Publisher 的函数 func publisher(for value: Int) -&gt; AnyPublisher&lt;Int, Never&gt; { // 这里我们创建一个将 Int 值封装在 Publisher 中的 Publisher return Just(value) .delay(for: .seconds(Double(value)), scheduler: RunLoop.main) .eraseToAnyPublisher() } // 源 Publisher，可以是任何类型的 Publisher let sourcePublisher = PassthroughSubject&lt;Int, Never&gt;() // 使用 map 来处理每个发送的值，并确保在任何时刻只有一个内部 Publisher 被订阅 sourcePublisher .map { value -&gt; AnyPublisher&lt;Int, Never&gt; in return publisher(for: value) } .switchToLatest() // 只订阅最新的内部 Publisher .sink(receiveCompletion: { completion in print(&quot;Completed with: \\(completion)&quot;) }, receiveValue: { value in print(&quot;Received value: \\(value)&quot;) }).store(in: &amp;cancellables) sourcePublisher.send(1) sourcePublisher.send(2) // 1 的结果会被忽略，因为 2 是最新的 sourcePublisher.send(3) // 2 的结果会被忽略，因为 3 是最新的 在这个例子中，sourcePublisher 是一个 PassthroughSubject，它可以发送值。每当它发送一个新的值，map 操作符会根据这个值创建一个新的 Publisher。然后，switchToLatest 只会订阅最新的 Publisher，之前的订阅会被取消，从而模拟出 flatMapLatest 的行为。 使用 map 和 switchToLatest 的组合是 Combine 中实现 flatMapLatest 的方式，我们也可以写一个flatMapLatest扩展操作方法。 extension Publisher { func flatMapLatest&lt;T: Publisher&gt;(_ transform: @escaping (Output) -&gt; T) -&gt; Publishers.SwitchToLatest&lt;T, Publishers.Map&lt;Self, T&gt;&gt; where T.Failure == Failure { return map(transform).switchToLatest() } } 这样的话可以把之前的代码简化成： // 使用 map 来处理每个发送的值，并确保在任何时刻只有一个内部 Publisher 被订阅 sourcePublisher .flatMapLatest { value -&gt; AnyPublisher&lt;Int, Never&gt; in return publisher(for: value) } .sink(receiveCompletion: { completion in print(&quot;Completed with: \\(completion)&quot;) }, receiveValue: { value in print(&quot;Received value: \\(value)&quot;) }).store(in: &amp;cancellables) ","link":"https://blog.xioayee.top/post/combine-li-mian-lei-si-flatmaplatest-de-cao-zuo-fang-fa/"},{"title":"如何通过IDA Pro跟踪按钮点击事件调用的函数地址","content":"如题，这篇文章主要是讨论研究如何定位到按钮点击事件的函数地址。 一般来说点击事件主要有以下两种方式： 按钮点击 一个按钮点击事件通常会发送一个WM_COMMAND消息给主窗口的过程， WM_COMMAND的十六进制是0x111，我们可以使用0x111进行搜索。 可以使用Spy++ 进行拦截WM_COMMAND消息，Spy++ 可能不会捕获到所有类型的按钮事件，特别是如果它们是由非标准方式处理的（例如，直接使用 SendMessage 或 PostMessage API）。 一些程序可能会使用 SendMessage 或 PostMessage API 来发送 WM_COMMAND 消息。在这些 API 调用上设置断点可以有助于找到消息发送的源头。 要捕获 SendMessage 或 PostMessage API 调用，需要一个能够监控这些函数调用的工具。Spy++ 可以监控消息，但它不会显示 API 调用的细节。我们可以使用 API Monitor 来进行拦截。 鼠标事件 有些事件是直接通过检测鼠标点击事件来调用对应的事件的，即使在UI上看到是个按钮，但也有可能是通过鼠标事件进行调用的。如何判断是否位鼠标调用，可以使用 API Monitor 来监测目标程序，然后勾上SetCapture函数，如果点击事件的时候会出现SetCapture的消息，那基本可以断定这个按钮事件是通过鼠标事件来调用的。 那么程序中是如何使用SetCapture来捕获并调用按钮事件的呢？我们又如何通过这些信息来定位到目标按钮事件函数呢？ 这是 SetCapture 函数的原型： HWND SetCapture(HWND hWnd); hWnd：指定要捕获鼠标输入的窗口的句柄。函数调用成功时返回之前捕获鼠标的窗口句柄，失败时返回 NULL。 通过使用 SetCapture 函数，可以确保一个窗口接收到所有的鼠标输入事件，即使光标当前不在窗口内。然而，SetCapture 本身并不用于“监听”或“捕获”鼠标点击事件。要监听鼠标事件，需要结合消息处理机制来处理通过 SetCapture 获得的鼠标输入。 以下是一个简化的例子，演示如何在一个 Win32 应用程序中捕获并处理鼠标点击事件： 调用 SetCapture 来确保你的窗口可以接收鼠标事件。 // hWnd 是目标窗口句柄 SetCapture(hWnd); 在目标窗口过程中处理鼠标消息。以下是窗口过程的一个基本示例： LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) { switch (message) { case WM_LBUTTONDOWN: // 当鼠标左键被按下时执行 break; case WM_LBUTTONUP: // 当鼠标左键被释放时执行 break; case WM_RBUTTONDOWN: // 当鼠标右键被按下时执行 break; case WM_RBUTTONUP: // 当鼠标右键被释放时执行 break; // 其它消息的处理 default: return DefWindowProc(hWnd, message, wParam, lParam); } return 0; } 当完成鼠标事件处理后，调用 ReleaseCapture 来释放鼠标捕获。 ReleaseCapture(); 在上面的代码中，WM_LBUTTONDOWN, WM_LBUTTONUP, WM_RBUTTONDOWN, 和 WM_RBUTTONUP 是当鼠标左键和右键分别按下和释放时发送到窗口的消息。可以在这些消息处理代码中实现对鼠标点击的监听逻辑。 接下来我们可以通过查找SetCapture，点击左侧Names这个tab，按Ctrl+F进行搜索SetCapture关键字，我们很快就可以找到SetCapture的地址，双击进入该地址，按键盘X显示xrefs来看看哪些地方引用了这个函数，一般程序很可能都只有一个地方使用这个函数，所有鼠标事件在一个地方集中处理，这个可以在xrefs窗口中的地址栏看出来，如果都是同一个地址只是加不同的偏移量的话，就是一个地方处理了。双击其中一个地址跳转到目标地址，按F5生成伪代码，可以看到Switch case伪代码，例如case 0x202:这个是鼠标点击被释放事件，一般是在这个事件中调用按钮事件。事实也证明是如此，成功在此处找到了对应的按钮处理事件，后续可以结合IDA Pro的动态调试功能进行验证。 虽然我们已经找到事件调用的主函数地址，但是具体按钮的调用函数还需进入这个函数进行分析，通过具体代码的分析才能真正找到当前按钮点击时间调用的函数。 ","link":"https://blog.xioayee.top/post/ru-he-tong-guo-ida-pro-gen-zong-an-niu-dian-ji-shi-jian-diao-yong-de-han-shu-di-zhi/"},{"title":"x86汇编浮点运算","content":"我们都知道汇编整形数加减运算可以使用add/sub来进行运算，比较简单，但是如果要进行浮点运行，就不能直接用add/sub来进行运算了，比较麻烦一些，所以今天把浮点运算方法记录一下，以免后面用到的时候又忘了。 浮点运算需要用到的几个指令： FLD：类似PUSH指令，把当前浮点数压入堆栈。 FILD：类似FLD，只是把整形数压入堆栈。 FSTP：类似POP指令，把堆栈顶部浮点数出栈。 FISTP：类似FSTP，只是把浮点数出栈为整形数。 需要注意的是FLD/FSTP不能直接压入寄存器的数据，只能压入寄存去指向的内存地址的数据。 下面是浮点数减法例子，思路是先转为整形数字，作减法后再转为浮点数。 fld dword ptr [edi+30] sub esp, 8 // 栈顶加多8位 fistp dword ptr [esp+4] sub [esp+4], 70 fild dword ptr [esp+4] fstp dword ptr [esp+4] 类型转换 int to float fild dword ptr [eax] Fstp dword ptr [eax] ","link":"https://blog.xioayee.top/post/x86-hui-bian-fu-dian-yun-suan/"},{"title":"汇编中如何封装已有的函数","content":"有时候反编译后发现函数是类的一个方法，因此调用函数的时候有部分参数是通过eax或者esi传进来的，不是直接push进堆栈。这时候我们如果要使用c语言进行调用会比较麻烦，所以我的想法是把这种函数进行二次封装，让eax或者esi作为push的形式传进去，这样c语言调用的时候就可以直接进行函数调用。 首先，我们需要扩展这个软件的内存，如果软件可以找到确定可用的内存地址块也可以直接使用，否则可以自行扩展，扩展内存后找到扩展内存的起始地址，写入汇编代码，这个汇编代码是我们封装已有函数的代码，这个起始地址则为我们调用函数的地址。 这时候这里有一个坑要注意，传参堆栈中不是直接拿的esp作为第一个参数，通过push传参数，然后call+目标地址，此时传进的参数不是[esp], 即不是栈顶，因call的时候会相当于把call指令下一行的地址push到栈顶，所以在call的函数里面拿参数要栈顶往下4个byte，即[esp+4]来拿这个参数。 最后，我们就可以使用c语言进行调用，但是直接调用hex地址还是不够优雅，我们需要用c函数封装一下，后面使用起来也不容易用错，例如： void createView(int viewAddr, int layerIndex, int offsetX, int offsetY) { ((void (*)(int, int, int, int))0x894000)(viewAddr, layerIndex, offsetX, offsetY); } ","link":"https://blog.xioayee.top/post/hui-bian-zhong-ru-he-feng-zhuang-yi-you-de-han-shu/"},{"title":"x86汇编中ESP和EBP区别","content":"我们知道ESP和EBP都是x86的CPU寄存器，在汇编中经常会用到，这两个比较容易搞混，我之前用了下，一段时间没用又记不清两者的区别和用法了，故写一篇文章记录下。 ESP (Extended Stack Pointer): ESP 寄存器是堆栈指针寄存器，它总是指向程序栈顶部的地址。在函数调用和返回过程中，ESP 用于跟踪栈上的最新数据。当数据被推送到栈上时，ESP 的值减小（因为栈在内存中向下增长），而当数据被弹出栈时，ESP 的值增加。 EBP (Extended Base Pointer): EBP 寄存器是基指针寄存器，它通常用于在函数调用期间作为参考点，来访问函数参数和局部变量。一般在函数的开始处，会将当前的 ESP 值复制到 EBP 中，这样无论栈指针如何移动，函数内部都可以通过 EBP 寄存器以一个固定的偏移量来访问其参数和局部变量。 简单来说ESP就是指向栈顶，EBP指向基址。ESP往栈底方向移动是用加偏移而不是减，栈底是高位地址（如上图），如[ESP+4], 4是偏移量。 以下是一个简单的例子，展示了在 x86 汇编语言中如何使用 ESP 和 EBP 寄存器： push ebp ; 将当前函数的EBP值保存到栈上 mov ebp, esp ; 将ESP的值复制到EBP，设置新的基点 sub esp, 32 ; 在栈上为局部变量分配32字节的空间 ; 在这里可以通过EBP加上偏移量来访问函数的参数和局部变量 mov esp, ebp ; 恢复ESP的值，撤销局部变量的空间 pop ebp ; 恢复调用函数的EBP值 ret ; 返回到调用函数的下一条指令 ","link":"https://blog.xioayee.top/post/x86-hui-bian-zhong-esp-he-ebp-qu-bie/"},{"title":"iOS架构探讨","content":"前言 iOS开发也比较长时间了，这么久的从业经验也积累了不少对iOS架构的经验，各种大大小小的项目，好的架构能给后期开发和团队合作带来很大的益处，其目标是构建一个结构清晰、易于维护且可扩展的系统。一个好的架构可以使得应用更加稳定，提高开发效率，降低长期维护的成本，所以在项目建立的时候就要根据项目的复杂度选择好的项目架构，这篇文章主要是来探讨总结一下iOS的架构方面的内容。 设计模式 熟悉并合理运用设计模式对于构建一个良好的架构至关重要。在iOS中，常见的架构模式包括： MVC (Model-View-Controller): Apple官方推荐的模式，但如果不当心，容易导致Controller过于臃肿（被称为Massive View Controller）。 MVP (Model-View-Presenter): 在MVC的基础上，Presenter取代了Controller的角色，负责逻辑处理，减轻了Controller的负担。 MVVM (Model-View-ViewModel): 引入ViewModel层，用于转换Model数据供View使用，减轻了Controller的责任，并有利于实现双向绑定。 VIPER (View-Interactor-Presenter-Entity-Router): 一种更复杂的架构，旨在通过分离关注点来提高可测试性和可维护性，但学习曲线较陡峭。 架构原则 理解并遵守一些基本的软件架构原则，如： SOLID原则：五大设计原则帮助开发者设计出易于维护和扩展的系统。 DRY (Don't Repeat Yourself)：避免重复代码，减少维护成本。 KISS (Keep It Simple, Stupid)：保持简单，避免过度设计。 YAGNI (You Aren't Gonna Need It)：不要设计当前用不到的功能。 依赖注入 依赖注入（Dependency Injection，DI）是一种减少组件间耦合的技术，可以使得代码更加模块化，易于测试和维护。 依赖注入的主要方式： 构造器注入（Constructor Injection）： 在创建类的实例时，通过构造器（初始化方法）将依赖项传递给该类。 属性注入（Property Injection）： 类的实例被创建之后，通过公开的属性来设置依赖项。 方法注入（Method Injection）： 依赖项通过方法的参数传递，通常用于传递某个方法调用所需的依赖项。 依赖注入容器： 在更复杂的应用中，可能会有多个类和多种依赖关系。在这种情况下，可以使用依赖注入容器（DI Container）来简化依赖管理。依赖注入容器是一个可以自动处理依赖关系的系统。在Swift中，我们可以手动创建一个容器，或者使用第三方库，如Swinject。 模块化与组件化 将应用分解为多个模块或组件，有利于代码的复用和UI统一，也有助于团队并行开发，并且使得代码更加清晰。 单元测试和自动化测试 通过单元测试和自动化测试，提高测试覆盖率，可以确保编写的代码是符合预期的，能提升代码质量，减少Bug的产生。 持续集成/持续部署（CI/CD） 设置CI/CD可以自动化测试和部署过程，确保代码的集成质量，加快发布速度，减少人工操作错误。 持续集成（CI） 持续集成是一种开发实践，开发团队成员频繁地将代码变更集成到共享仓库中。一般情况下，这意味着开发者每天至少集成一次，这样可以快速发现并解决集成错误，减少集成问题。 CI的关键实践包括： 版本控制：所有代码变更都应提交到版本控制系统中，如Git。 自动化构建：使用自动化工具（如Xcode Server, Jenkins, GitLab CI, CircleCI, Travis CI等）来编译和构建应用。 自动化测试：自动化执行单元测试和集成测试，确保代码变更没有破坏现有功能。 快速反馈：如果构建或测试失败，团队成员应立即得到通知。 维护构建系统：保持构建过程的速度和可靠性。 性能优化 重视性能分析和优化，包括内存管理、线程与并发处理、网络请求优化等。 安全性 确保应用的安全性，包括代码混淆、数据加密、防止注入攻击、安全传输等。 实践建议 代码审查：定期进行代码审查，可以提高代码质量并分享知识。 文档与注释：保持良好的文档和代码注释习惯，有助于团队成员理解架构和代码。 重构：不要害怕重构代码，持续重构是保持架构健康的重要手段。 ","link":"https://blog.xioayee.top/post/ios-jia-gou-tan-tao/"},{"title":"TCP连接三次握手","content":"经典面试题，今天我们来了解一下TCP连接三次握手的过程。 TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。建立一个TCP连接需要经过一个被称为&quot;三次握手&quot;（three-way handshake）的过程，目的是在两个通信端（通常是客户端和服务器）之间建立一个可靠的连接。下面是三次握手的详细步骤： SYN（同步序列编号） 客户端发送一个SYN（synchronize）标志位被设置为1的TCP段，以便开始一个新的连接。此时客户端选择一个初始序列号（Sequence Number）X，用来标识传输的数据字节流中的第一个字节。 客户端进入SYN_SENT状态，等待服务器确认。 SYN+ACK（同步和确认） 服务器接收到客户端的SYN请求后，需要确认客户端的SYN，同时自己也发送一个SYN请求。服务器发送一个TCP段，其中SYN和ACK（acknowledgment）标志位都被设置为1，确认号（Acknowledgment Number）设置为X+1（确认收到客户端的SYN，并期望收到序列号为X+1的数据），同时选择自己的一个初始序列号Y。 服务器进入SYN_RCVD状态。 ACK（确认） 客户端收到服务器的SYN+ACK响应后，发送一个ACK确认。这个TCP段中ACK标志位被设置为1，序列号设置为X+1，确认号设置为Y+1。 客户端进入ESTABLISHED状态，此时连接建立成功。 服务器收到客户端的ACK后也进入ESTABLISHED状态。 ","link":"https://blog.xioayee.top/post/tcp-lian-jie-san-ci-wo-shou/"},{"title":"给你的网站加上https","content":"如今网络安全越来越重要了，各大浏览器已经开始限制用户访问非https网站了，如果你的网站现在还没配置支持https，那么你的访问量将极大受到影响。 说起https，最让人头痛的就是要申请证书和生成公钥和秘钥，如今，随着科技的发展，这些繁琐的事情都成为过去，今天我就来为大家介绍最简便和免费的方法。 首先，你得有一个网站服务器和域名，网站我们使用nginx提供http/https服务，https证书我们使用Let's encrypt提供的免费证书，这个证书有效期为90天，所以我们需要定时去renew这个证书确保他有效。 在Debian 9下，我们先su root到root管理员权限下安装nginx $ sudo apt update $ apt install nginx 随后安装Certbot's Nginx包，这个包会自动帮我们获取指定域名的证书，还会自动帮我们配置好nginx的ssl证书部分，具体后面会介绍。 $ apt install python-certbot-nginx -t stretch-backports $ vi /etc/nginx/sites-available/example.com $ ln -s /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/ $ nginx -t $ systemctl restart nginx server { listen 80; listen [::]:80; root /var/www/example.com/html; index index.html index.htm index.nginx-debian.html; server_name example.com www.example.com; location / { try_files $uri $uri/ =404; } } 参考自： How To Secure Nginx with Let's Encrypt on Debian 9 ","link":"https://blog.xioayee.top/post/2018-12-10-enable-website-https-for-your-blog/"},{"title":"读《别让猴子跳回背上》","content":" 最近买了这本猴子书，当然这里面的“猴子”并不是真的猴子，按书里面的定义是要我们工作中要做的下一步。拿到书那一刻，看到书的排版，吓了一跳，边距也太大了吧，估计内容也多不到哪去。然后我就花了两个多晚上就看完了，内容实在是少。 啰哩啰嗦的讲了一大堆，其实就是说你是领导，要时时刻刻作为监工，而不能出现和下属交换角色的情况。遇到下属有问题需要你帮忙，你最多和他一起讨论，最终还是要让下属去做，下属永远是做事的人，而领导永远是监督的职责。 日常工作中可能会出现下属请示领导工作，不知不觉就把自己的工作让领导给做了，还时不时询问领导事情的进展，这时猴子就爬到领导背上了，领导需要去喂养本来不属于他的猴子，而猴子的主人，由于没有猴子喂养，而出现怠工的状态。这时领导要做的是赶紧和下属谈话，把不属于自己的猴子还给下属，即使这样做会有些痛苦。为了避免出现这种痛苦，当下属找领导帮忙的时候，领导就应该和下属分清好职责，只能当面给些指导或者讨论意见，或者让下属出份内容报告和报告简要目录，找时间再和下属面对面谈话解决问题，而不是自己把猴子领养过来，最重要的一点就是不要出现下属反过来询问领导工作进度的情况。询问工作进度永远只是领导向下属询问，因为领导是监工的角色。 还有工作中发现的猴子可能会很多，应该做好计划，排好优先度，让下属清晰知道什么时候要做好，按照时间计划开会，无特殊原因不能修改会议时间，即使没做完或者根本还没开始做也要进行会议。猴子积压太多，可以适当杀掉一些猴子，不要让猴子腐烂发臭，影响工作。 另外一点就是不要越级领导下属，除非出现非常紧急的情况，没有办法的情况下才能越级领导。越级领导会造成很严重的后果，正确做法是直接领导向你汇报的下属，让他去领导好他的下属，达到事半功倍的效果。 The End ","link":"https://blog.xioayee.top/post/2018-07-18-monkey/"},{"title":"Shell 的一些笔记","content":"if -e and -n的意思？ 如果目标不为 null 则返回 true -e returns true if the target exists. Doesn't matter if it's a file, pipe, special device, whatever. The only condition where something may exist, and -e will return false is in the case of a broken symlink. For example: $ ln -s foo bar $ [ -e foo ]; echo $? 1 $ touch bar $ [ -e foo ]; echo $? 0 In bash you can do help test to see what test options you have. [ is usually part of your shell. In bash the options and behaviors are defined by bash. It is also kind of a synonym for test. In bash you can do help test to see all the options it supports. The only real difference between [ and test should be that [ requires a ] after your arguments, whereas test does not. They otherwise work the same, [ -e foo ] is equivalent to test -e foo. There is also /usr/bin/[ for shells which do not have [ built in. There is no man page for this though. But there is also a /usr/bin/test, and my system does have a man test which covers the options. I haven't tested, but I'd bet all the options supported by /usr/bin/test work on /usr/bin/[. Primary Meaning [ FILE1 -ef FILE2 ] True if FILE1 and FILE2 refer to the same device and inode numbers. [ -o OPTIONNAME ] True if shell option &quot;OPTIONNAME&quot; is enabled. [ -z STRING ] True of the length if &quot;STRING&quot; is zero. [ -n STRING ] or [ STRING ] True if the length of &quot;STRING&quot; is non-zero. More details: Introduction to if Tests 比较操作符 整型比较符： 操作符 说明 例子 -eq 相等 if [ &quot;a&quot;−eq&quot;a&quot; -eq &quot;a&quot;−eq&quot;b&quot; ] -ne 不相等 -gt 大于 -ge 大于或等于 -lt 小于 -le 小于或等于 &lt; 小于 ((&quot;a&quot;&lt;&quot;a&quot; &lt; &quot;a&quot;&lt;&quot;b&quot;)) &lt;= 小于或等于 &gt; 小于 &gt;= 大于或等于 字符串比较符： 操作符 说明 例子 = 等同 == 相当于= != 不相同 &lt; if [[ &quot;a&quot;&lt;&quot;a&quot; &lt; &quot;a&quot;&lt;&quot;b&quot; ]] if [ &quot;a&quot;&lt;&quot;a&quot; \\\\&lt; &quot;a&quot;&lt;&quot;b&quot; ] -z 字符串为 null if [ -z &quot;$s&quot; ] -n 字符串不为 null How to exit if a command failed? http://stackoverflow.com/questions/3822621/how-to-exit-if-a-command-failed If you want that behavior for all commands in your script, just add set -e set -o pipefail at the beginning of the script. This pair of options tell the bash interpreter to exit whenever a command returns with a non-zero exit code. This does not allow you to print an exit message, though. Quoting Variables 双引号&quot;&quot; 的作用是使里面的字符除了`\\之外都不作解析，因此在使用变量variable 的时候尽量加上双引号，以减少符号的解析和防止误解析。 单引号'' 则不会解析里面的$字符。 Exit and Exit Status 每个命令都会返回退出状态，成功的命令返回状态0，而失败的命令则返回非零。 $?获取前面最后一条命令的退出状态。 Grep Convert binary file to string and search string. strings &lt;file_path&gt; | grep &quot;&lt;string&gt;&quot; Find more files to search the string. find . -name &quot;*.zip&quot; | xargs string | grep &quot;string&quot; The End ","link":"https://blog.xioayee.top/post/2018-07-18-shell-study-note/"},{"title":"使用 go 进行 OpenCV 学习与开发","content":"前言 记得开始使用 OpenCV 的时候是在大学时期，当时用的是 C 语言，OpenCV 版本好像是1.1，随着时间的推移，后面 C++逐渐代替了 C，iOS 也有整合好的 lib 可以使用 OpenCV，现在Python, go 等语言进行开发，今天主要是说一说如何使用 go 语言配置开发 OpenCV。 库的选择 使用 Opencv 2+的话，可以用这个库 https://github.com/go-opencv/go-opencv，但这个库没有支持 OpenCV 3+, 所以想用 OpenCV 3+ 可以使用https://github.com/hybridgroup/gocv，今天主要就是介绍 gocv 的使用。 环境配置 如果还没安装 OpenCV 的话， Mac OS可以通过 brew install opencv 进行安装OpenCV 3.4.1。 安装好 go 之后，直接运行 go get -u -d gocv.io/x/gocv 命令获取 gocv 库，进入该库根目录 cd $GOPATH/src/gocv.io/x/gocv, 运行 source ./env.sh，然后就可以使用 go run命令运行里面的示例了，刚开始学可以直接在示例里面修改代码运行。 IDE 的选择 本来想使用 IDEA + go plugin 的方式来开发，谁知 IDEA 出了 go IDE（需要收费），go plugin 就停止维护了，只能放弃，随后选择 vscode+plugin 的方式，方便快捷，感觉也不错，智能提示和代码跳转都有了，调试还没试，估计调试和 run 的话都是可以配置的。 示例 配置好之后迫不及待就写代码了，由于 gocv 对 OpenCV 进行了封装，方法名基本都一致，但是使用上还是有些区别，不过 vscode 代码跳转很方便，不清楚直接跳到源码看看就知道了，下面贴一个查找边框的例子，看看是不是和 C++的写法很不一样。 // What it does: // // This example uses the Window class to open an image file, and then display // the image in a Window class. // // How to run: // // go run ./cmd/showimage/main.go /home/ron/Pictures/mcp23017.jpg // // +build example package main import ( &quot;fmt&quot; &quot;image&quot; &quot;image/color&quot; &quot;os&quot; &quot;gocv.io/x/gocv&quot; ) func main() { if len(os.Args) &lt; 2 { fmt.Println(&quot;How to run:\\n\\tshowimage [imgfile]&quot;) return } filename := os.Args[1] window := gocv.NewWindow(&quot;Hello&quot;) img := gocv.IMRead(filename, gocv.IMReadColor) grayImage := gocv.NewMat() defer grayImage.Close() gocv.CvtColor(img, &amp;grayImage, gocv.ColorBGRToGray) destImage := gocv.NewMat() gocv.Threshold(grayImage, &amp;destImage, 100, 255, gocv.ThresholdBinaryInv) resultImage := gocv.NewMatWithSize(500, 400, gocv.MatTypeCV8U) gocv.Resize(destImage, &amp;resultImage, image.Pt(resultImage.Rows(), resultImage.Cols()), 0, 0, gocv.InterpolationCubic) gocv.Dilate(resultImage, &amp;resultImage, gocv.NewMat()) gocv.GaussianBlur(resultImage, &amp;resultImage, image.Pt(5, 5), 0, 0, gocv.BorderWrap) results := gocv.FindContours(resultImage, gocv.RetrievalTree, gocv.ChainApproxSimple) imageForShowing := gocv.NewMatWithSize(resultImage.Rows(), resultImage.Cols(), gocv.MatChannels4) for index, element := range results { fmt.Println(index) gocv.DrawContours(&amp;imageForShowing, results, index, color.RGBA{R: 0, G: 0, B: 255, A: 255}, 1) gocv.Rectangle(&amp;imageForShowing, gocv.BoundingRect(element), color.RGBA{R: 0, G: 255, B: 0, A: 100}, 1) } if img.Empty() { fmt.Println(&quot;Error reading image from: %v&quot;, filename) return } for { window.IMShow(imageForShowing) if window.WaitKey(1) &gt;= 0 { break } } } 我是用 showimage.go 这个示例改的，处理顺序是： 灰度化 CvtColor 二值化 Threshold 缩小图片 Resize 膨胀 Dilate 高斯模糊 GaussianBlur 查找轮廓 FindContours 绘制轮廓 DrawContours 绘制轮廓的最小外接矩形 Rectangle 从上面例子可以看到，方法都是在 package gocv下，使用的时候会有代码提示，包括参数也有提示，由于 go 没有类构造方法，都是使用 New+类型名称这样的函数还创建类型。 我也是 go 的新手，这里是边看着文档边写的代码，还好有智能代码提示，用起来还算得心应手，希望这篇入门文章对想使用 go 来进行 OpenCV 开发的同学有所帮助。 The End ","link":"https://blog.xioayee.top/post/2018-05-14-opencv-go/"},{"title":"iOS 物理引擎实践之模拟粒子运动","content":"最近看到一个使用 javascript 编写的模拟粒子运动的库verlet-js，效果很不错，于是就想把他移植到 iOS 上，花了点时间使用 swift 把代码移植了过来，最后还加了一个粒子系统的 demo，源代码已经放到 github 上了: https://github.com/MellongLau/ParticleAnimation。 下面放上Demo效果截图： The End ","link":"https://blog.xioayee.top/post/2018-04-28-particle-animation-ios/"},{"title":"Swift 中定义单例","content":"什么是单例 单例模式（Singleton Pattern），也叫单子模式，是一种常用的软件设计模式。 在应用这个模式时，单例对象的类必须保证只有一个实例存在。 单实例Singleton设计模式可能是被讨论和使用的最广泛的一个设计模式了，这可能也是面试中问得最多的一个设计模式了。这个设计模式主要目的是想在整个系统中只能出现一个类的实例。这样做当然是有必然的，比如你的软件的全局配置信息，或者是一个Factory，或是一个主控类，等等。 如何在 swift 中创建单例 在 swift 中有以下这两种方式可以创建单例 全局变量的方式 let sharedNetworkManager = NetworkManager(baseURL: API.baseURL) class NetworkManager { // MARK: - Properties let baseURL: URL // Initialization init(baseURL: URL) { self.baseURL = baseURL } } 使用该全局变量进行引用 func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool { print(sharedNetworkManager) return true } 静态属性及私有化构造方法的方式 class NetworkManager { // MARK: - Properties private static var sharedNetworkManager: NetworkManager = { let networkManager = NetworkManager(baseURL: API.baseURL) // Configuration // ... return networkManager }() // MARK: - let baseURL: URL // Initialization private init(baseURL: URL) { self.baseURL = baseURL } // MARK: - Accessors class func shared() -&gt; NetworkManager { return sharedNetworkManager } } 直接调用类方法进行引用 NetworkManager.shared() 参考自： What Is a Singleton and How To Create One In Swift The End ","link":"https://blog.xioayee.top/post/2018-03-07-swift_singleton/"},{"title":"Raspbian安装vscode","content":"vscode是一个跨平台，轻量级，开源免费，具有强大插件支持编辑器，这不是微软的风格。经过长时间的使用，笔者现在已经爱上这款编辑器，之前一直用的是sublime text2, 现在基本舍弃之。 vscode应该是目前为止最适合开发angular的编辑器，安装上相关的插件后会有代码提示，代码检查，代码自动完成，自动模块导入，自动更正等。此外，我还喜欢使用vscode来写markdown文档，写shell scirpt, python, php等。安装相关的插件后，vscode简直是一款神器！ 这篇文章暂时不会具体介绍vscode的用法，这里主要是介绍如何在树梅派上安装vscode。 在树梅派上安装vscode我是走了不少弯路， 由于官网没有编译好支持armhf的安装包供下载，只好自己去git clone下来源代码进行编译。 这里有篇文章介绍，不过可惜的是花了很长时间还是编译不出来，最后不得不放弃。 https://www.hanselman.com/blog/BuildingVisualStudioCodeOnARaspberryPi3.aspx 没法自己编译，那就找找有没有好心人编译好安装包供下载的。果然在网上找到一位大牛提供的安装包，这位大牛还专门写了个网站介绍安装方法。 https://code.headmelted.com/ 我是用的Rapbian, 使用的是下面命令进行安装 . &lt;( wget -O - https://code.headmelted.com/installers/apt.sh ) 安装过程会遇到需要添加force命令参数的错误，可以先wget apt.sh把脚本下载到本地上修改一下再安装，提示permission问题的话加上sudo给予权限就可以了。 安装成功后直接在终端输入 code-oss 启动vscode就可以了。启动时间还可以接受，响应速度还不错，安装了很多插件，暂时还没发现会对响应速度造成大的影响。非常推荐安装！ The End ","link":"https://blog.xioayee.top/post/2017-09-30-raspbian-install-vscode/"},{"title":"写了个iOS下拉刷新控件","content":"这个控件和LiteAutolayout一样也写了有一段时间了，使用swift实现，尽量做到简单易用，尽可能做到一行代码搞定。 先附上CocoRongPullToRefresh的源码地址： https://github.com/MellongLau/CocoRongPullToRefresh 下拉刷新功能应该是所用 app 中使用最频繁的功能了， 这个组件为你的 table view提供了最简单使用方式的下拉刷新特性。 用法 下面代码是简单使用这个控件的例子 tableView.cr.enablePullRefresh { // 调用远程服务器的接口. get(&quot;http://xxx.com/api/productlist&quot;) { dataList in // 更新 table view 的数据源 self.tableView.datasource = dataList self.tableView.reloadData() // 完成刷新 self.tableView.cr.stopRefresh() } } 如你所看到的，我们只要上面几行代码就可以为你的 table view 添加下来刷新功能，如果你想要修改下拉刷新视图的背景颜色，可以参考下面代码： tableView.cr.tintColor = UIColor.brown 最后，别忘了在view controller 的 deinit 方法中调用 remove() 方法移除当前页面对 CocoRongPullToRefresh 的引用。 deinit { tableView.cr.remove() } 使用示例 下载 example 文件夹下的示例项目查看具体的用法。 安装 这里有两种方式添加 CocoRongPullToRefresh 到你的项目中。 CocoaPods CocoaPods 推荐使用这种方式添加 CocoRongPullToRefresh 到你的项目中. 添加 CocoRongPullToRefresh 到 podfile. pod &quot;CocoRongPullToRefresh&quot;, &quot;~&gt; 1.0&quot; 使用命令 pod install 安装所有的库. 引用 CocoRongPullToRefresh： import CocoRongPullToRefresh . 手动安装 使用 Terminal.app 运行以下命令: $ git clone https://github.com/MellongLau/CocoRongPullToRefresh.git 或者直接下载并拷贝 CocoRongPullToRefresh 文件夹和添加引用到你的项目中. 要求 需要 Swift 3.0+ and iOS 8.0+ and ARC. 使用 CocoRongPullToRefresh? 如果你在你的项目中使用了 CocoRongPullToRefresh，请发邮件(邮件地址在下面)告诉我一声，我会把你的 app 的下载链接添加到这里！ 贡献 欢迎为此项目提供任何的帮助，包括意见建议，资金，代码或者精神鼓励等，为此项目贡献代码请提交 pull request, 代码经过审核后会立即合并到主分支中 The End ","link":"https://blog.xioayee.top/post/2017-09-24-pull-to-refresh-component/"},{"title":"Swift 之访问控制","content":"访问控制对访问你的其他代码源文件和模块部分进行了约束。这个特性允许你隐藏你的代码实现，并且指定通过其可以访问和使用该代码的优选接口。 class，structure 和 enumeration 都可以指定访问级别，当然，property，method，initializer 和 属于这里类型的 subscript。protocol 可以限制到某个上下文，全局变量，变量和函数也可以。 另外，Swift 也提供默认的使用级别给典型的使用场景。确实，如果你编写一款单一目标的 app，你可能根本不需要明确地指定访问控制级别。 模块和源文件 Swift的访问控制模型是基于模块和源文件的概念。 一个模块是单个的代码分布单元————一个 framework 或者应用程序是作为单个单元编译和传递的，他们能够通过 Swift 的 import 关键字被其他模块导入。 在Swift 中， Xcode的每一个 build target（如 一个 app bundle 或者 framework）被当成一个单独的模块。 虽然通常做法是在不同的源文件定义不同的类型，然而一个源文件事实上可以包含不同的类型，函数等的定义。 访问级别 Swift 为你的代码实体提供5个不同的访问级别： Open 访问和 public 访问允许实体能够被使用在任何来自起决定作用的模块的源文件，或者来自于其他被导入的模块的源文件。通常使用 open 或者 public 来指定framework 的公开接口。两者的不同点将在下面进行描述。 Internal 访问允许实体被使用在他们定义模型的任何源文件里面，但是不能在模块外部的任何源文件使用。通常在定义一个 app 或者一个 framework 的内部结构的时候使用 internal 访问。 File-private 访问限制了在定义源文件中实体的使用。使用 file-private 访问来隐藏特定功能的实现细节，当这些细节在整个文件中使用的时候。 Private 访问将实体的使用限制在封闭声明中。使用 private 访问来隐藏特定功能的实现细节，当这些细节在单个声明使用时。 Open 访问是最高访问级别，private 是最低访问级别（最大限制性）。 Open 访问只用在类和类成员，他和 publick 访问的区别如下： 使用 public 访问的类， 或者其他更多限制性的访问级别，只能在定义的模块内创建子类。 使用 public 访问的类成员，或者其他更多限制性的访问级别，只能在定义的模块内被其子类重写。 Open 类可以被定义的模块或者其他 import 该模块的地方创建子类。 Open 类成员可以被定义的模块或者其他 import 该模块的地方创建的子类重写。 简单来说就是 public 和 open 的区别就是public 比 open 少了模块外的类继承和类成员重写的权限。 访问级别的指导原则 在 Swift 中，访问级别遵从总的指导原则是：没有实体可以被定义在另外一个拥有较低访问级别（更多限制）的实体之内。 例如： public变量不能被定义为具有internal, file-private或者 private 类型，因为这种类型可能不能用在使用公共变量的任何地方。 函数不能具有比其他参数类型和返回类型更高的访问级别，因为该函数可以在其组成类型不可被周围代码使用的情况下使用。 下面会有更详细的介绍。 默认的访问级别 如果你自己没有指定一个明确的访问级别，所有代码中的实体都有一个默认的internal访问级别。结果，在很多情况下你不需要对你的代码指定明确的访问级别。 单目标应用程序的访问级别 如果你写的是一个 i 简单的单目标应该程序，那么你的程序代码就是典型的自包含程序，并不需要在程序模块的外部进行使用。默认的访问级别 internal 已经满足这个需求。因此，你不需要去指定一个访问级别。然而，你可能需要把你部分的代码标记为文件私有或者私有，从而使得在程序模块中的其他代码隐藏他们的实现细节。 Frameworks 的访问级别 当你开发一个 framework，标记 open 或者 public 以便它能够被其他模块访问到，例如某个程序引入这个 framework 的时候。这个面向公众的接口是framework 的程序编程接口（或者 API）。 值得注意的是：任何 framework 的内部实现细节都还可以使用默认的内部访问级别，或者可以标识为私有或者文件私有级别，如果你想对framework 的其他部分内部代码隐藏他们的话。只有当你想让一个实体成为你的 framework 的 API 的一部分的话，那么你就需要把这个实体标识为 open 或者 public。 单元测试目标的访问级别 当你写的是一个包含单元测试目标的程序时，那么你需要让你程序中的代码可以被测试模块使用到以便于测试。一般情况下，只有被标识为 open 或者 public 的实体才可以被其他模块访问到。然而，如果你把产品的模块 import 声明前加入 @testable 属性并且在打开测试选项下编译产品模块的话，那么单元测试目标就能够访问任何的 internal 实体。 访问级别语法 为实体定义访问级别： public class SomePublicClass {} internal class SomeInternalClass {} fileprivate class SomeFilePrivateClass {} private class SomePrivateClass {} public var somePublicVariable = 0 internal let someInternalConstant = 0 fileprivate func someFilePrivateFunction() {} private func somePrivateFunction() {} 除非有其他的指定，否则的话默认的访问基本是 internal，这也就意味着 SomeInternalClass 和 someInternalConstant 能够在不明确访问级别修饰符的情况下也还拥有 internal 的访问级别： class SomeInternalClass {} // 隐式 internal let someInternalConstant = 0 // 隐式 internal 翻译自：https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-ID3 The End ","link":"https://blog.xioayee.top/post/2017-08-12-swift-access-control/"},{"title":"Swift 之泛型","content":"泛型代码允许你编写灵活，可以重用适用于任何类型的函数和类型。 大部分的Swift标准库都是用泛型代码编写。Array和Dictionary事实上都是泛型集合。你可以创建Int值的数组，或者String值的数组，以及其他swift类型的数组。Dictionary也是类似的。 一般情况我我们这样写函数 func swapTwoInts(_ a: inout Int, _ b: inout Int) { let temporaryA = a a = b b = temporaryA } 使用in-out关键字的参数可以修改外部传入的变量的值 var someInt = 3 var anotherInt = 107 swapTwoInts(&amp;someInt, &amp;anotherInt) print(&quot;someInt is now \\(someInt), and anotherInt is now \\(anotherInt)&quot;) // Prints &quot;someInt is now 107, and anotherInt is now 3&quot; 可以看到外部定义的变量经过swapTwoInts(_:_:)函数交换了值。这里我们直接定义的是Int类型的值交换，如果我们想交换String或者Double的类型的值，那我们还得重新写对应类型的函数： func swapTwoStrings(_ a: inout String, _ b: inout String) { let temporaryA = a a = b b = temporaryA } func swapTwoDoubles(_ a: inout Double, _ b: inout Double) { let temporaryA = a a = b b = temporaryA } 从上面的代码可以看到，这几个函数的代码除了类型不一样之外，其他都是一样的，那么这时我们可以用泛型来进行定义。 Generic Functions 泛型函数可以适配任何类型。 func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) { let temporaryA = a a = b b = temporaryA } 看看和上面指定类型写法的区别 func swapTwoInts(_ a: inout Int, _ b: inout Int) func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) 泛型函数定义好之后，我们就可以直接调用 var someInt = 3 var anotherInt = 107 swapTwoValues(&amp;someInt, &amp;anotherInt) // someInt is now 107, and anotherInt is now 3 var someString = &quot;hello&quot; var anotherString = &quot;world&quot; swapTwoValues(&amp;someString, &amp;anotherString) // someString is now &quot;world&quot;, and anotherString is now &quot;hello&quot; 上面这个函数只是为了举例说明泛型的用法，实际使用中我们可以直接使用Swift已经存在的函数swap(_:_:)来交换两个变量的值。 类型参数 你可以在尖括号内写多个类型参数名称, 用逗号隔开。函数被调用的时候，这些类型参数将会被替换成实际的类型。 类型参数的命名 可以采用类似Dictionary&lt;Key, Value&gt;, 或者Array的命名方式，如果类型参数跟实际类型没有多大搞关联，也可以使用单个字母T, U, 和 V，例如swapTwoValues(::)就是用的 T 作为类型参数。 另外，类型参数命名的首字母要大写，例如 T 和 MyTypeParameter，这是为了表明这些是类型的占位符，而不是一个值。 泛型类型 在Swift中，我们可以自己定义泛型类型。自定义类，结构体和枚举都可以使用和数组，字典类似的任何类型。 这部分主要展示给你是一个实现泛型集合类型的栈，UINavigationController 中就有使用到栈的概念。 结合下面图例更容易理解： 下面是没有使用泛型版本的栈： struct IntStack { var items = [Int]() mutating func push(_ item: Int) { items.append(item) } mutating func pop() -&gt; Int { return items.removeLast() } } 当然，只支持 Int 的栈并不能满足我们的项目需求，所以下面是使用泛型版本： struct Stack&lt;Element&gt; { var items = [Element]() mutating func push(_ item: Element) { items.append(item) } mutating func pop() -&gt; Element { return items.removeLast() } } 这里使用泛型参数Element代替实际类型Int, 使用尖括号写在结构名称后面。后面所有地方都可以用Element表示类型， 使用的时候只需在初始化的时候写 Stack(), 则表明这个是一个字符串栈: var stackOfStrings = Stack&lt;String&gt;() stackOfStrings.push(&quot;uno&quot;) stackOfStrings.push(&quot;dos&quot;) stackOfStrings.push(&quot;tres&quot;) stackOfStrings.push(&quot;cuatro&quot;) // the stack now contains 4 strings 具体才栈操作相信大家已经非常熟悉了，这里就不再赘述。 扩展泛型类型 下面是一个扩展泛型栈类型的例子： extension Stack { var topItem: Element? { return items.isEmpty ? nil : items[items.count - 1] } } 这里为栈添加了一个只读的 topItem 属性。 topItem 这个计算属性现在可以在任何的栈实例中被使用，可以用它来获取栈的顶部元素，但不移除这个元素。 if let topItem = stackOfStrings.topItem { print(&quot;The top item on the stack is \\(topItem).&quot;) } // Prints &quot;The top item on the stack is tres.&quot; 类型约束 有些时候我们需要给泛型类型加上约束，例如指定类型参数必须继承某个指定的类，或者遵循某个协议或者协议组合。 例如Dictionary类型对 key 做了限制， key 必须是遵循 Hashable 协议的。其中，Swift 的基本类型（String，Int，Double和 Bool）默认都是遵循 Hashable 协议的。 在创建自定义泛型类型的时候，你也可以定义你自己的类型约束。 类型约束符号 如下例所示，为类型参数添加类型约束的时候，可以在类型参数的名称后面加入一个类或者协议的约束，多个类型参数可用逗号隔开： func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) { // function body goes here } 上面例子中中，第一个类型参数 T 的类型约束是：T 必须是 SomeClass 的子类。第二个类型参数 U 则必须遵循协议 SomeProtocol。 类型约束实践 这里有一个非泛型函数叫 findIndex(ofString:in:)，这个函数提供一个 String 值来查找一个String 数组。findIndex(ofString:in:)函数返回一个 optional Int 值，返回匹配的字符串在数组中的位置，如果不存在这个字符串则返回 nil： func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? { for (index, value) in array.enumerated() { if value == valueToFind { return index } } return nil } findIndex(ofString:in:)函数可以用来查找数组中的字符串： let strings = [&quot;cat&quot;, &quot;dog&quot;, &quot;llama&quot;, &quot;parakeet&quot;, &quot;terrapin&quot;] if let foundIndex = findIndex(ofString: &quot;llama&quot;, in: strings) { print(&quot;The index of llama is \\(foundIndex)&quot;) } // Prints &quot;The index of llama is 2&quot; 然而，只能查找数组中字符串值位置的理念不是很好用。你可以通过替换任何字符串为类型 T 来代替，写一个相同功能的泛型函数。 这里我们把findIndex(ofString:in:) 修改为泛型版本 findIndex(of:in:)。值得注意的是，返回类型依然是 Int?，因为函数返回一个optional 索引数字，而不是 来自数组的 optional 值。下面这个函数不能编译，后面会解释原因： func findIndex&lt;T&gt;(of valueToFind: T, in array:[T]) -&gt; Int? { for (index, value) in array.enumerated() { if value == valueToFind { return index } } return nil } 上面所写的这个函数不能编译。问题在于相等性的检查，&quot;if value == valueToFind&quot;。不是任何类型在 Swift 中都可以使用操作符（==）进行相等比较。例如，如果你创建你自己的类或者结构体来展现一个复杂的数据模型，那么对于这个类或结构体的&quot;equal to&quot; 的含义不是 Swift 能够帮你猜到的。正因为如此，不可能保证这些代码对于所有可能的类型 T 都可行，同时当你试图编译这些代码的时候有提示相应的错误。 但是，你还没有失去一切。Swift 标准库定义一个协议叫 Equatable，这个协议要求所有遵循的类型要实现相等操作符（==）和不等操作符（!=）来比较两个不同类型的值。所有的 Swift 标准类型都自动支持 Equatable protocol。 任何是 Equatable 的类型都能够安全地在findIndex(of:in:)函数中使用，因为他保证支持相等操作符。为了验证这个事实，当你定义函数的时候，你可以写一个类型约束于 Equatable 的类型参数定义： func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array:[T]) -&gt; Int? { for (index, value) in array.enumerated() { if value == valueToFind { return index } } return nil } findIndex(of:in:)的单一类型参数写作 T: Equatable，这样写的意思是&quot;任何遵循于协议 Equatable 的类型 T&quot;。 findIndex(of:in:)函数现在可以成功编译，并能够被使用任何是 Equatable 的类型，如 Double 和 String： let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25]) // doubleIndex is an optional Int with no value, because 9.3 is not in the array let stringIndex = findIndex(of: &quot;Andrea&quot;, in: [&quot;Mike&quot;, &quot;Malcolm&quot;, &quot;Andrea&quot;]) // stringIndex is an optional Int containing a value of 2 关联类型 当定义一个协议的时候，有时候声明一个或多个关联类型作为协议定义的一部分是很有用的。一个关联类型提供一个类型的占位名，这个类型被用作协议的一部分。用于关联类型的实际类型直到协议被采用时才被指定。关联类型使用associatedtype关键字指定。 关联类型实践 这里是一个声明了一个关联类型叫 ItemType 名字为 Container 的协议示例： protocol Container { associatedtype ItemType mutating func append(_ item: ItemType) var count: Int { get } subscript(i: Int) -&gt; ItemType { get } } 协议 Container 定义了任何容器必须提供的三个要求的功能： 必须可以使用 append(_:)方法添加一个新的项目。 必须可以通过使用一个返回 Int 值的 count 属性来访问容器中的项目数。 必须可以通过一个 Int 索引值的下标来获取容其中每个项目。 这个协议并没有指明容器中应该保存多少项目或者允许什么类型保存。这个协议只是指明任何看作为 Container 的类型必须提供这三种功能。一个符合的类型可以提供额外的功能，只要它满足这个三个要求就可以了。 Container 协议声明一个关联类型叫 ItemType，写作 associatedtype ItemType。这个协议没有定义 ItemType 是什么，这个信息留给任何符合的类型来提供。尽管如此，ItemType 别名提供一个方法在 Container 中引用项目的类型，并且定义一个类型给 append(_:)方法和下标使用，从而确保任何 Container 期望的行为被执行。 翻译自： https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179 The End ","link":"https://blog.xioayee.top/post/2017-08-07-swift-generic/"},{"title":"终端使用中遇到的问题","content":"文件出现 ^M 问题 ^M 是回车符，他是源于 DOS/Windows 的，但是在 Unix 的系统中这样的符号在执行的时候会报错，在使用 vim 查看文件的时候会直接看到^M 而不是换行。 想替换掉^M，换成\\r或者\\n, 千万不要直接打上符号^M 进行替换，^M 这个符号要使用 ctrl+v &amp; ctrl+m 生成，在 vim 中使用 :%s/^M/\\r/g 进行替换所有回车符。 Git SVN Issue 使用 git svn 的时候报一下错误： Can't locate SVN/Core.pm in @INC (you may need to install the SVN::Core module) (@INC contains: /usr/local/git/lib/perl5/site_perl/5.18.2/darwin-thread-multi-2level /usr/local/git/lib/perl5/site_perl/5.18.2 /usr/local/git/lib/perl5/site_perl /Library/Perl/5.18/darwin-thread-multi-2level /Library/Perl/5.18 /Network/Library/Perl/5.18/darwin-thread-multi-2level /Network/Library/Perl/5.18 /Library/Perl/Updates/5.18.2 /System/Library/Perl/5.18/darwin-thread-multi-2level /System/Library/Perl/5.18 /System/Library/Perl/Extras/5.18/darwin-thread-multi-2level /System/Library/Perl/Extras/5.18 .) at /usr/local/git/lib/perl5/site_perl/Git/SVN/Utils.pm line 6. BEGIN failed--compilation aborted at /usr/local/git/lib/perl5/site_perl/Git/SVN/Utils.pm line 6. Compilation failed in require at /usr/local/git/lib/perl5/site_perl/Git/SVN.pm line 25. BEGIN failed--compilation aborted at /usr/local/git/lib/perl5/site_perl/Git/SVN.pm line 32. Compilation failed in require at /usr/local/git/libexec/git-core/git-svn line 21. BEGIN failed--compilation aborted at /usr/local/git/libexec/git-core/git-svn line 21. 参考这个问题: http://stackoverflow.com/questions/16578465/on-osx-using-sourcetree-git-svn-getting-cant-locate-svn-core-pm-in-inc 解决方法： sudo mkdir /Library/Perl/5.18/auto sudo ln -s /Applications/Xcode.app/Contents/Developer/Library/Perl/5.18/darwin-thread-multi‌-2level/SVN /Library/Perl/5.18/darwin-thread-multi-2level sudo ln -s /Applications/Xcode.app/Contents/Developer/Library/Perl/5.18/darwin-thread-multi‌-2level/auto/SVN /Library/Perl/5.18/auto/ ","link":"https://blog.xioayee.top/post/2017-08-02-terminal-issue/"},{"title":"Vim常用操作命令","content":"Vim是非常强大的文本编辑器，熟练使用vim会给使用linux带来很大帮助，现在很多流行的编辑器都以插件的形式支持vim编辑模式，也从另一面说明vim非常的流行。 使用 Vim 有很长一段时间了，感觉就是越熟悉越好用，刚开始用还是比较痛苦的，所以我把一些常用的命令记下来，有了下面这些命令，使用起 vim 就会更得心应手了。 删除 dd: 删除整行。 dt+&quot;字符&quot;: 删除当前字符到指定字符，但不包含自定字符。 df+&quot;字符&quot;: 删除当前字符到指定字符，且包含自定字符。 di+&quot;括号或者双引号，单引号，方括号等&quot;: 删除当前的成对的括号内的全部字符，不包括括号。 da+&quot;括号或者双引号，单引号，方括号等&quot;: 删除当前的成对的括号内的全部字符，包括括号。 cw: 删除单词并切换为 insert 模式。 ss: 删除当前字符并切换为 insert 模式。 复制粘贴 yy: 复制当前行。 yw: 复制当前字符。 yW: 复制当前单词。 &quot;复制行数&quot;+yy: 复制当前行及以下行数的行。 p: 复制后进行粘贴,P则当前行前粘贴，p 在当前行后粘贴。 Ve 水平分割文件浏览 Ex 当前窗口文件浏览? Se 垂直分割文件浏览 s 文件浏览中点击 s 进行切换排序模式 r 文件浏览中点击 r 进行切换为方向排序 v 文件浏览中点击 v 在新的水平窗口中打开目录或文件 ctrl+w,+hjkl 窗口间切换 :bn :bp 文件切换 [n]+&gt;&gt; 选择 n 行缩进 &quot;:ls&quot;查看当前打开的buffer（文件） &quot;:b num&quot;切换文件（其中num为buffer list中的编号） :split 垂直新建分割窗口 :sp :vsplit 水平新建分割窗口 :vsp ","link":"https://blog.xioayee.top/post/2017-07-29-vim-tips/"},{"title":"自制自动布局约束开源库Lite Auto Layout","content":"首先，贴上这个库的源码地址：https://github.com/MellongLau/LiteAutoLayout 这个库也写了好长一段时间了，由于最近忙，一直都没时间把它更新好放上来，特别是文档，拖了这么久总算是补全了一点了。至于好不好用，那就见仁见智了，我之前比较习惯用IB拖auto layout的约束，也是根据IB的使用概念来实现的这个库，下面也有提到这一点，所以，个人认为，习惯使用IB来布局的同学应该会比较容易上手和习惯使用吧。 然后就是，如果—— 喜欢这个项目？ 点击Github 里面的 Star按钮支持我们吧! 示例项目 可以下载 Demo 文件夹下的示例项目运行，下面是运行后的截图。 这是一个使用 LiteAutoLayout 编写布局约束的登录框界面，所有的约束代码都在下面的代码截图中： 简介 最近在用 Swift 3.0，Swift 3.0给我们带来了很多新的特性，在学习过程中发现自定义操作符这个写法很适合来写 autolayout 的约束，结合自己平时使用 IB 来创建视图之间的约束的经验，决定使用自定义操作符来让使用代码创建约束更加直观，清晰和简单。 其中，~&gt; 这个符号被我用来作为视图约束于其同级视图或者父级视图的表达式，如 (view1 ~&gt; view2), 中间需要留空格，而创建对于自身的约束，可以使用(~&gt;view1)来创建，中间不需要留空格，后面添加约束是用的简单方便的链式写法。 当然，如果你不想使用~&gt;这个符号来创建约束，我还提供了startLayout()的方法直接创建约束，如： view1.startLayout(toView: view2)。 另外，因为项目中使用 IB 编写界面比较多，同时也觉得 IB 添加约束的用法比较简单和方便，所以这里使用的设置约束的方法是用了 IB 添加约束的概念，相信有用过 IB 应该都比较容易接受这种写法，在使用 LiteAutoLayout 后相信会加深对 IB 添加布局约束的理解，两种的使用相互促进，相互提高，这也是这个库的优势之一。 比较 NSLayoutConstraint vs NSLayoutAnchor vs LiteAutoLayout 如设置两个视图之间垂直的距离约束verticalSpacing(), 值得注意的是~&gt;后面的视图默认是在上方，如果是添加水平距离，则~&gt;后面的视图是在左边。 这个库是一个简单的封装，如果你使用过 sdk 原始创建约束的方法的话，你应该会被其繁琐的写法所吓倒。 这里引用 apple 官网的一个例子： // 使用 NSLayoutConstraint 创建约束 NSLayoutConstraint(item: subview, attribute: .Leading, relatedBy: .Equal, toItem: view, attribute: .LeadingMargin, multiplier: 1.0, constant: 0.0).active = true NSLayoutConstraint(item: subview, attribute: .Trailing, relatedBy: .Equal, toItem: view, attribute: .TrailingMargin, multiplier: 1.0, constant: 0.0).active = true // 使用 Layout Anchors 创建相同的约束 let margins = view.layoutMarginsGuide subview.leadingAnchor.constraintEqualToAnchor(margins.leadingAnchor).active = true subview.trailingAnchor.constraintEqualToAnchor(margins.trailingAnchor).active = true 上面可以看到直接使用 NSLayoutConstraint 创建简单的布局约束需要繁复的代码，使用 NSLayoutAnchor 可以简化约束代码，那 LiteAutoLayout 到底表现如何，下面我们用 LiteAutoLayout 创建相同的布局约束： // 使用 Lite Auto Layout 创建相同的约束 (subview ~&gt; view).leading().trailing() 显然，使用 LiteAutoLayout 甚至比 NSLayoutAnchor 还简单，并且代码阅读更加清晰易懂，而且 NSLayoutAnchor 目前只支持 iOS9+，LiteAutoLayout 目前支持 iOS7+。 最后，需要注意的是： 左边是子视图，右边为父视图(subview ~&gt; view, 左侧的subview 是 view 的子视图)。 左边是位于右边的视图的右侧或者下方(view2 ~&gt; view1, 则 view2 在 view1的右侧或者下方)。 目前支持的特性： 支持&gt;=, &lt;=, ==操作符。 支持指定优先级。 支持链式写法。 如何安装 下载文件 LiteAutoLayout.swift 并将其复制到项目文件夹下，添加引用到项目中即可。 使用 LiteAutoLayout? 如果你在你的项目中使用了 LiteAutoLayout，请发邮件(邮件地址在下面)告诉我一声，我会把你的 app 的下载链接添加到这里！ 贡献 欢迎为此项目提供任何的帮助，包括意见建议，资金，代码或者精神鼓励等，为此项目贡献代码请提交 pull request, 代码经过审核后会立即合并到主分支中。 License MIT License ","link":"https://blog.xioayee.top/post/2017-06-07-lite-auto-layout-introduction/"},{"title":"iOS如何跳转到Facebook指定用户界面","content":"第一步，先要检测Facebook是否安装，如果安装就直接跳转到app里面指定的用户主页，否则直接用浏览器打开指定的用户主页网页地址。 BOOL isInstalled = [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;fb://&quot;]] if (isInstalled) { // 直接跳转到app里面指定的用户主页。 } else { // 用浏览器打开指定的用户主页网页地址。 } 值得注意的是，iOS9+需要的Info.plist里面加上键名为LSApplicationQueriesSchemes加上值：fb。 使用下面代码进行跳转： NSURL *url = [NSURL URLWithString:@&quot;fb://profile/&lt;facebook id&gt;&quot;]; [[UIApplication sharedApplication] openURL:url]; 可以通过这个网站获取到你的Facebook id：http://findmyfbid.com/ ","link":"https://blog.xioayee.top/post/2017-03-12-ios-facebook-shre/"},{"title":"Swift 3.0之下标","content":"类，结构体和枚举都可以定义下标，使用下标可以快速访问集合，列表或者序列的数据成员元素。可以使用someArray[index]来访问Array， 使用someDictionary[key]来访问Dictionary。 一个类型可以定义多个下标。 定义一个get set的下标： subscript(index: Int) -&gt; Int { get { // return an appropriate subscript value here } set(newValue) { // perform a suitable setting action here } } 定义一个read-only的下标 subscript(index: Int) -&gt; Int { // return an appropriate subscript value here } 例子： struct TimesTable { let multiplier: Int subscript(index: Int) -&gt; Int { return multiplier * index } } let threeTimesTable = TimesTable(multiplier: 3) print(&quot;six times three is \\(threeTimesTable[6])&quot;) // Prints &quot;six times three is 18&quot; 还可以使用多个下标, 任何类型，除了in-out类型的参数 struct Matrix { let rows: Int, columns: Int var grid: [Double] init(rows: Int, columns: Int) { self.rows = rows self.columns = columns grid = Array(repeating: 0.0, count: rows * columns) } func indexIsValid(row: Int, column: Int) -&gt; Bool { return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns } subscript(row: Int, column: Int) -&gt; Double { get { assert(indexIsValid(row: row, column: column), &quot;Index out of range&quot;) return grid[(row * columns) + column] } set { assert(indexIsValid(row: row, column: column), &quot;Index out of range&quot;) grid[(row * columns) + column] = newValue } } } 参考翻译英语原文： https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Subscripts.html#//apple_ref/doc/uid/TP40014097-CH16-ID305 ","link":"https://blog.xioayee.top/post/2017-03-12-swift3-subscripts/"},{"title":"Swift中如何把UILabel数字的颜色设置为红色","content":"这篇文章源于群友的一个问题：如何把**『注：此商品只能整件(12的倍数发货),已选1袋,还差11袋』**这段文字中的数字使用红色在 UILabel 中显示？ 大概思路是：我们可以使用UILabel 的 attribute string 属性，通过正则表达式匹配获取数字的范围，然后添加对应的 attribute。 下面是实现代码，使用 swift 3.0 编写： //根据正则表达式改变文字颜色 func changeTextChange(regex: String, text: String, color: UIColor) -&gt; NSMutableAttributedString { let attributeString = NSMutableAttributedString(string: text) do { let regexExpression = try NSRegularExpression(pattern: regex, options: NSRegularExpression.Options()) let result = regexExpression.matches(in: text, options: NSRegularExpression.MatchingOptions(), range: NSMakeRange(0, text.characters.count)) for item in result { attributeString.addAttribute(NSForegroundColorAttributeName, value: color, range: item.range) } } catch { print(&quot;Failed with error: \\(error)&quot;) } return attributeString } let text = &quot;注：此商品只能整件(12的倍数发货),已选1袋,还差11袋&quot; let renderLabel = UILabel(frame: CGRect(x: 0, y: 0, width: 800, height: 30)) renderLabel.textAlignment = NSTextAlignment.center renderLabel.backgroundColor = UIColor.lightGray renderLabel.font = UIFont.boldSystemFont(ofSize: 20) renderLabel.attributedText = changeTextChange(regex: &quot;\\\\d+&quot;, text: text, color: UIColor.red) 可以把以上这段代码放到 playground 里面运行。 当然，这里可以不使用正则表达式，用其他方法也可以做到，但是正则表达式的做法比较灵活，以后如果有新的需求可以直接修改正则表达式就可以实现。 ","link":"https://blog.xioayee.top/post/2017-03-12-swift-uilabel-number-color-set-to-red-color/"},{"title":"Swift 3.0之枚举","content":"枚举在编程中很多时候要用到，在 Swift 中，枚举具有更多的特性。 枚举语法 使用关键字 enum 定义一个枚举 enum SomeEnumeration { // enumeration definition goes here } 例如，指南针有四个方向： enum CompassPoint { case north case south case east case west } 这里跟 c 和 objective-c 不一样的是，Swift 的枚举成员在创建的时候没有给予默认的整型值。所以上面代码中的东南西北并不是0到3，相反，不同的枚举类型本身就是完全成熟的值，具有明确定义的CompassPoint类型。 也可以声明在同一行中： enum Planet { case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune } 枚举赋值： var directionToHead = CompassPoint.west 一旦 directionToHead 明确为 CompassPoint 类型的变量，后面就可以使用点语法赋值： directionToHead = .east Switch 表达式的枚举值匹配 switch 表达式如下： directionToHead = .south switch directionToHead { case .north: print(&quot;Lots of planets have a north&quot;) case .south: print(&quot;Watch out for penguins&quot;) case .east: print(&quot;Where the sun rises&quot;) case .west: print(&quot;Where the skies are blue&quot;) } // Prints &quot;Watch out for penguins&quot; 当然这里也可以加上 default 以满足所有的情况： let somePlanet = Planet.earth switch somePlanet { case .earth: print(&quot;Mostly harmless&quot;) default: print(&quot;Not a safe place for humans&quot;) } // Prints &quot;Mostly harmless&quot; 关联值 在 Swift 中，使用枚举来定义一个产品条形码： enum Barcode { case upc(Int, Int, Int, Int) case qrCode(String) } 可以这样理解上面这段代码：定义一个叫 Barcode 的枚举类型，带有值类型（Int,Int,Int,Int）的 upc和值类型（String） 现在可以这样创建其中一种类型的条形码： var productBarcode = Barcode.upc(8, 85909, 51226, 3) 同一产品的另外一个类型的条形码可以这样赋值： productBarcode = .qrCode(&quot;ABCDEFGHIJKLMNOP&quot;) 可以用 switch 来查看两种不同的条形码类型： switch productBarcode { case .upc(let numberSystem, let manufacturer, let product, let check): print(&quot;UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).&quot;) case .qrCode(let productCode): print(&quot;QR code: \\(productCode).&quot;) } // Prints &quot;QR code: ABCDEFGHIJKLMNOP.&quot; 上面的写法也可以改为： switch productBarcode { case let .upc(numberSystem, manufacturer, product, check): print(&quot;UPC : \\(numberSystem), \\(manufacturer), \\(product), \\(check).&quot;) case let .qrCode(productCode): print(&quot;QR code: \\(productCode).&quot;) } // Prints &quot;QR code: ABCDEFGHIJKLMNOP.&quot; 原始值 这里是一个保存原始 ASCII 值的枚举类型： enum ASCIIControlCharacter: Character { case tab = &quot;\\t&quot; case lineFeed = &quot;\\n&quot; case carriageReturn = &quot;\\r&quot; } 和上面关联值类似，在枚举中也可以指定每个 case 的默认值（raw values）。 值得注意的是，原始值和关联值不一样，原始值是在第一次定义枚举代码的时候已经设置好的，所有同类型的枚举 case 的原始值都是一样的。而关联值是你创建一个基于枚举 case新的常量或者变量的时候设置的，可以在每次你创建的时候都使用不一样的值。 隐式分配的原始值 如果枚举中 case 的原始值是整型或者字符串的时候，你不需要给每个 case 分配原始值，Swift 会自动帮你分配好值。 例如： enum Planet: Int { case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune } Planet.mercury 原始值为1，Planet.venus 拥有一个隐式的原始值为2，以此类推。 如果枚举的原始值是 string 类型，那么他的原始值就是 case 名称的文本，例如： enum CompassPoint: String { case north, south, east, west } CompassPoint.south 的隐式原始值是&quot;south&quot;, 以此类推。 let earthsOrder = Planet.earth.rawValue // earthsOrder is 3 let sunsetDirection = CompassPoint.west.rawValue // sunsetDirection is &quot;west&quot; 从原始值初始化 如果你定义一个原始值类型的枚举，这时枚举会自动创建一个带有原始值类型的初始化器（参数名称为 rawValue），例如： let possiblePlanet = Planet(rawValue: 7) // possiblePlanet is of type Planet? and equals Planet.uranus 不是所有的 Int 值都可以找到对应的 planet，所以原始值初始化器会返回一个 optional 的枚举 case，上面的例子中的 possiblePlanet 是 Planet? 类型。 如果你想找原始值为11的 planet，初始化器将返回 nil： let positionToFind = 11 if let somePlanet = Planet(rawValue: positionToFind) { switch somePlanet { case .earth: print(&quot;Mostly harmless&quot;) default: print(&quot;Not a safe place for humans&quot;) } } else { print(&quot;There isn't a planet at position \\(positionToFind)&quot;) } // Prints &quot;There isn't a planet at position 11&quot; 递归枚举 递归枚举是一个包含有一个或多个枚举 case 的关联值枚举实例的枚举，使用关键字 indirect 标明某个枚举 case 是递归的。 例如，下面是一个保存简单算法表达式的枚举： enum ArithmeticExpression { case number(Int) indirect case addition(ArithmeticExpression, ArithmeticExpression) indirect case multiplication(ArithmeticExpression, ArithmeticExpression) } 你也可以直接把 indirect 写在枚举定义的最前面： indirect enum ArithmeticExpression { case number(Int) case addition(ArithmeticExpression, ArithmeticExpression) case multiplication(ArithmeticExpression, ArithmeticExpression) } 下面的代码是示例如何创建这个递归枚举： let five = ArithmeticExpression.number(5) let four = ArithmeticExpression.number(4) let sum = ArithmeticExpression.addition(five, four) let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2)) 应用到计算函数中： func evaluate(_ expression: ArithmeticExpression) -&gt; Int { switch expression { case let .number(value): return value case let .addition(left, right): return evaluate(left) + evaluate(right) case let .multiplication(left, right): return evaluate(left) * evaluate(right) } } print(evaluate(product)) // Prints &quot;18&quot; 上面例子的算法表达式是：(5 + 4) * 2，结果为18 参考英语原文： https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145 ","link":"https://blog.xioayee.top/post/2017-03-12-enumerations-swift-3/"},{"title":"pod setup命令失败解决方法","content":"最近运行pod setup出现以下问题： remote: Compressing objects: 100% (34/34), done. error: RPC failed; curl 56 SSLRead() return error -3613.00 KiB/s fatal: The remote end hung up unexpectedly fatal: early EOF fatal: index-pack failed 我们知道 cocoapods 的 sepcs 文件是放在这个目录里面 ~/.cocoapods/repos 所以可以直接 cd 到该目录下然后运行命令: git clone https://github.com/CocoaPods/Specs.git master Cloning into 'master'... remote: Counting objects: 894306, done. remote: Compressing objects: 100% (56/56), done. ^Cceiving objects: 6% (53659/894306), 10.39 MiB | 216.00 KiB/s ... 然后会发现clone 的文件很大，由于速度也很慢，一不小心就失败了。 其实我们无需全部 clone 下来，可以只 clone 最近一个 commit 的全部代码就可以了。 git clone --depth=1 https://github.com/CocoaPods/Specs.git master Cloning into 'master'... remote: Counting objects: 261047, done. remote: Compressing objects: 100% (179891/179891), done. remote: Total 261047 (delta 44498), reused 253721 (delta 44409), pack-reused 0 Receiving objects: 100% (261047/261047), 44.76 MiB | 124.00 KiB/s, done. Resolving deltas: 100% (44498/44498), done. Checking connectivity... done. Checking out files: 100% (118515/118515), done. 不用多久就 clone 成功了，这时候就直接可以使用pod install 最新版本的 library 了。 ","link":"https://blog.xioayee.top/post/2017-03-12-pod-setup-wait-too-long-time/"},{"title":"Swift 3.0之扩展","content":"扩展可以为类，结构体，枚举和协议添加新的功能。包括可以对没有源码访问权限的类型进行扩展。扩展和 Objective-C 分类 的概念类似。（和 Objective-C 的分类不一样的是，Swift 扩展没有名称）。 在 Swift 中，扩展可以做到： 添加计算的实例属性和计算的类型属性 定义实例方法和类型方法 提供新的初始化器 定义下标 定义并使用新的嵌套类型 使现有类型符合协议 值得注意的是：扩展可以为类型添加功能，但是不可以重写现有的功能。 扩展语法 使用关键字 extension 定义扩展： extension SomeType { // new functionality to add to SomeType goes here } 扩展可以扩充现有的类型使之可以适应一个或多个协议： extension SomeType: SomeProtocol, AnotherProtocol { // implementation of protocol requirements goes here } 计算属性 扩展可以为现有的类型添加计算实例属性和计算类型属性: extension Double { var km: Double { return self * 1_000.0 } var m: Double { return self } var cm: Double { return self / 100.0 } var mm: Double { return self / 1_000.0 } var ft: Double { return self / 3.28084 } } let oneInch = 25.4.mm print(&quot;One inch is \\(oneInch) meters&quot;) // Prints &quot;One inch is 0.0254 meters&quot; let threeFeet = 3.ft print(&quot;Three feet is \\(threeFeet) meters&quot;) // Prints &quot;Three feet is 0.914399970739201 meters&quot; 由于这些属性是只读计算属性，所以他们不需要加入关键字 get。 可以直接进行运算： let aMarathon = 42.km + 195.m print(&quot;A marathon is \\(aMarathon) meters long&quot;) // Prints &quot;A marathon is 42195.0 meters long&quot; 值得注意的是：扩展可以添加新的计算属性，但是他们不可以添加存储属性，或者为现有的属性添加属性观察器。 初始化器 扩展可以向类添加新的方便初始化器，但是它们不能向类添加新的指定的初始化器或取消初始化器。 指定的初始化器和取消初始化器必须始终由原始类实现提供。 下面定义几个结构体： struct Size { var width = 0.0, height = 0.0 } struct Point { var x = 0.0, y = 0.0 } struct Rect { var origin = Point() var size = Size() } 我们可以这样来创建 Rect 实例（关于默认初始化器可以查看初始化部分的文章）： let defaultRect = Rect() let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0)) 这时，我们可以扩展 Rect 结构体，为其添加新的初始化器： extension Rect { init(center: Point, size: Size) { let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) } } 然后我们就可以使用新的初始化方法来创建实例： let centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0)) // centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0) 方法 下面是为Int 类型添加一个叫repetitions的方法： extension Int { func repetitions(task: () -&gt; Void) { for _ in 0..&lt;self { task() } } } 然后我们可以这样调用这个方法： 3.repetitions { print(&quot;Hello!&quot;) } // Hello! // Hello! // Hello! 变异实例方法 添加了扩展的实例方法也可以修改（或变异）实例本身。 修改self或其属性的结构和枚举方法必须将实例方法标记为mutating，就像原始实现中的突变方法一样。 如下面的例子： extension Int { mutating func square() { self = self * self } } var someInt = 3 someInt.square() // someInt is now 9 下标 想实现 123456789[0] 返回 9 123456789[1] 返回 8 代码如下: extension Int { subscript(digitIndex: Int) -&gt; Int { var decimalBase = 1 for _ in 0..&lt;digitIndex { decimalBase *= 10 } return (self / decimalBase) % 10 } } 746381295[0] // returns 5 746381295[1] // returns 9 746381295[2] // returns 2 746381295[8] // returns 7 如果下标越界，则返回0： 746381295[9] // returns 0, as if you had requested: 0746381295[9] 嵌套类型 扩展添加嵌套类型： extension Int { enum Kind { case negative, zero, positive } var kind: Kind { switch self { case 0: return .zero case let x where x &gt; 0: return .positive default: return .negative } } } 现在嵌套的类型可以在任何 Int 值中使用： func printIntegerKinds(_ numbers: [Int]) { for number in numbers { switch number.kind { case .negative: print(&quot;- &quot;, terminator: &quot;&quot;) case .zero: print(&quot;0 &quot;, terminator: &quot;&quot;) case .positive: print(&quot;+ &quot;, terminator: &quot;&quot;) } } print(&quot;&quot;) } printIntegerKinds([3, 19, -27, 0, -6, 0, 7]) // Prints &quot;+ + - 0 - 0 + &quot; 参考英语原文： https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151 The End ","link":"https://blog.xioayee.top/post/2016-12-08-swift-3-extensions/"},{"title":"迁移到swift3.0有用的技巧","content":"不久之前swift3.0发布了，新版本可以在Xcode 8中使用了，或者你可以直接从swift.org下载编译器。 从代码可读性来看，新版本有很多提升，函数调用的连续性，更好的命名约定和移除了部分c风格的元素。 从代码可读性来来看，NS前缀已经从Foundation类型中移除，例如NSBundle.mainBundle()现在改为Bundle.mainBundle(). c风格的一元操作符++和--在3.0中已经不适用了： // Only in Swift 2.2 and earlier var number = 10 number++ ++number number-- --number 相对应的表达方式是number += 1 or number -= 1. 另外一个有趣的变化是移除了c风格的for-loop,我记得在学校中（使用c语言）写这种循环： // Only in Swift 2.2 and earlier let steps = 5 for var step = 0; step &lt; steps; step++ { print(step) } // 0 1 2 3 4 主要的原因是存在了更好的对应写循环的方法for-in和stride().for-loop在理解上比较困难和缺少swift风格。当新的方法出现后，for-loop已经很少在代码库中使用了。 这篇文章将讲解典型的for-loop使用场景，同时说明迁移到 for-in, stride()或者简单的while() {}. 1. 如何迁移 for-loop 到 for-in for-loop 应用的典型场景在一个数字区间内迭代。这些数字可以是数组的索引等. 例如，让我们遍历数组的每一个元素： // Only in Swift 2.3 and earlier let birds = [&quot;pigeon&quot;, &quot;sparrow&quot;, &quot;titmouse&quot;] for var index = 0; index &lt; birds.count; index++ { print(birds[index]) } // &quot;pigeon&quot; &quot;sparrow&quot; &quot;titmouse&quot; 可见，let index = 0; index &lt; birds.count; index++ 的循环部分是冗长的。许多元素是多余的，整个表达式可以简化的。替换为手动的增量，整个操作可以用更具表达性的语法来自动化。 for-in 循环更简短和更具表达性。让我们迁移上面的代码： let birds = ['pigeon', 'sparrow', 'titmouse'] for index in 0..&lt;birds.count { print(birds[index]) } // 'pigeon', 'sparrow', 'titmouse' 现在感觉好很多了。index in 0..&lt;birds.count 更容易阅读和理解。0..&lt;birds.count 这部分定义一个半开区间的 Range 类型。for-in 循环迭代0，1和2的范围值（不包括上限3）。 这不是全部！ 你甚至可以跳过索引并直接访问数组元素： let birds = [&quot;pigeon&quot;, &quot;sparrow&quot;, &quot;titmouse&quot;] for bird in birds { print(bird) } // &quot;pigeon&quot; &quot;sparrow&quot; &quot;titmouse&quot; 可以看出，对于标准数组或集合迭代for-in对于for-loop是一个更好的替代。 至少在这种情况下，在Swift 3.0中删除for-loop的决定是合理的。 2. 如何迁移 for-loop 到 stride 你可以合理地要求for-loop虽然是冗长的，但仍然是灵活的。 它对于更复杂的迭代是有用的。 让我们尝试一个场景。你要打印一个具有奇数索引元素的元素数组。一个 for-loop 可能看起来像这样： // Only in Swift 2.3 and earlier let colors = [&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;, &quot;white&quot;, &quot;black&quot;] for var index = 0; index &lt; colors.count; index += 2 { print(colors[index]) } // =&gt; &quot;blue&quot; &quot;red&quot; &quot;black&quot; 由于索引根据表达式 index += 2而每次增加2，所以只有奇数索引的元素会被显示：&quot;blue&quot;, &quot;red&quot; and &quot;black&quot;. 你可以尝试使用 for-in 并定义一个范围。但是需要奇数索引加上附加的验证： let colors = [&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;, &quot;white&quot;, &quot;black&quot;] for index in 0..&lt;colors.count { if (index % 2 == 0) { print(colors[index]) } } // =&gt; &quot;blue&quot; &quot;red&quot; &quot;black&quot; 的确， if (index % 2 == 0) { ... } 条件句在这里看起来怎么样。 这种情况很符合使用 Swift 的stride(from: value, to: value, by: value)函数。定义开始，结束（不包括上限）和步长值，函数返回相应的数字序列。 让我们在我们的场景中应用stride： let colors = [&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;, &quot;white&quot;, &quot;black&quot;] for index in stride(from: 0, to: colors.count, by: 2) { print(colors[index]) } // =&gt; &quot;blue&quot; &quot;red&quot; &quot;black&quot; stride(from: 0, to: colors.count, by: 2) 返回以0开始到5的数字（上限不包含5），步长为2。对于 for-loop，这是一个好的替代。 如果上限必须包含进来，这里有另外一种函数格式： stride(from: value, through: value, by: value)。第二个参数的标签是 through， 这个标签是用以指明是包含上限的。 3. 其他情况坚持使用while c风格for-loop的每个组件都有一个很好的属性：初始化，跳出严重和完全可配置的增量： for &lt;initialization&gt;; &lt;verification&gt;; &lt;increment&gt; { // loop body } 此外，你可以省略其中的任何组件，要是你能在for-loop的循环块打破循环。 例如，让我们打印一个数字数组的元素，直到数字0被遇到。可以使用C风格的for-loop: // Only in Swift 2.2 and earlier let numbers = [1, 6, 2, 0, 7], nCount = numbers.count for var index = 0; index &lt; nCount &amp;&amp; numbers[index] != 0; index++ { print(numbers[index]) } // =&gt; 1 6 2 验证部分 index &lt; nCount &amp;&amp; numbers[index] != 0 是用以检查是否0在数组中出现。如果出现，则跳出循环。 所以只有0之前的数字被打印出来：1，6和2。 for var index in 0..&lt;nCount 是一个迁移选项。你只是需要使用条件 if numbers[index] == 0 ，当0出现的时候跳出循环： let numbers = [1, 6, 2, 0, 7], nCount = numbers.count for index in 0..&lt;nCount { if (numbers[index] == 0) { break } print(numbers[index]) } // =&gt; 1 6 2 但 break 语句出现，它会轻微减少阅读流程。但是我想要容易地阅读代码流程！ while(&lt;condition&gt;) {...} 循环可能是一个更好的替代方案。让我们看看上一个例子是如果被修改的： let numbers = [1, 6, 2, 0, 7], nCount = numbers.count var index = 0 while (index &lt; nCount &amp;&amp; numbers[index] != 0) { print(numbers[index]) index += 1 } // =&gt; 1 6 2 如果你有的情况无法使用 for-in 或者 stride(), 那么我推荐你使用 while(){}。 4. 统一参数标签行为 在Swift 2.2 和更早版本你可以在调用函数的时候忽略第一个参数的标签： // Only in Swift 2.2 and earlier func sum(firstItem: Int, secondItem: Int) -&gt; Int { return firstItem + secondItem } sum(5, secondItem: 2) // =&gt; 7 对于我来说，这个忽略的做法给我带来困扰。你不得不忽略第一个参数的标签，然而剩下的参数却还保持有标签。这是一种不自然的规则。 幸运的是从3.0版本开始，所有参数将强制拥有标签。 让我们来迁移上一个例子： func sum(firstItem: Int, secondItem: Int) -&gt; Int { return firstItem + secondItem } sum(firstItem: 5, secondItem: 2) // =&gt; 7 myFun(firstParam: 1, secondParam: 2)看起来更好。你知道严格的参数含义。简单，一致和清晰的方式。 如果你因为某些原因想在Swift 3.0中调用函数的时候忽略第一个标签，使用_ 作为那个参数的参数标签： func sum(_ firstItem: Int, secondItem: Int) -&gt; Int { return firstItem + secondItem } sum(5, secondItem: 2) // =&gt; 7 然而从长远来看我不推荐这种做法。他破坏了Swift代码中函数/方法调用的一致性。 Swift 命名向导 有很多有用的命名方面的建议。 5. 总结 Swift 3.0 做了一个很好的修改列表。其中大部分是重大的修改，所以你必须花些功夫来迁移Swift 2.3或者更旧的代码。 Swift 的制造者花了很多功夫来使这门语言用起来尽可能的舒服。 有时候，这个过程产生重大更改。幸运的是相比提高代码的可读性和跨语言语法的一致性来说，这是一个相对小的代价。 C风格的元素如for-loop，一元增量和减量运算被删除。对于这些结构Swift提供了更好的选择。 例如C语言风格的for循环很容易由for-in所取代。你可以使用stride()函数来进行更多可配置的迭代。 我最喜欢的改进是Swift 3.0引入了函数参数标签的一致性和清晰度。简单易记的规则：始终指明参数的标签。 我建议你也访问Swift 3.0官方的迁移向导。 英文原文链接：https://rainsoft.io/useful-tips-for-migrating-to-swift-3-0/ ","link":"https://blog.xioayee.top/post/2016-11-10-tips-for-migrating-to-swift3/"},{"title":"Swift 3.0之闭包","content":"写在前面 Swift引进了闭包的概念，这个与object-c的block类似，使用过block的话都知道有多方便，所以开始学Swift，先要把闭包学会，后面使用会很频繁。 开始 闭包的书写格式如下： { (parameters) -&gt; return type in statements } 如 reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } ) 使用的时候可以简化为 reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } ) 也可以简化为 reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } ) 甚至可以简化为 reversedNames = names.sorted(by: { $0 &gt; $1 } ) $0为第一个参数，以此类推 返回布尔值的话可以直接给一个判断符号，如 reversedNames = names.sorted(by: &gt;) 尾部闭包 reversedNames = names.sorted() { $0 &gt; $1 } 或者(无其他参数的情况下） reversedNames = names.sorted { $0 &gt; $1 } 这两个方式均可 捕捉值 如下代码，闭包可以获取和修改其周围的变量 func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int { var runningTotal = 0 func incrementer() -&gt; Int { runningTotal += amount return runningTotal } return incrementer } 以上函数返回一个闭包，闭包里添加了读取和修改闭包的外部变量runningTotal let incrementByTen = makeIncrementer(forIncrement: 10) incrementByTen() // returns a value of 10 incrementByTen() // returns a value of 20 incrementByTen() // returns a value of 30 闭包引用类型 可以通过用这种方式引用闭包并且调用： let alsoIncrementByTen = incrementByTen alsoIncrementByTen() @escaping 传递给函数的闭包如果不是在函数内调用，而是在函数内用外部变量保存当前的闭包，在合适的时间再进行调用，这是就需要在闭包参数前加入@escaping关键字，不然编译器会报错。 比较好理解的就是经常用到的网络请求，请求完成才执行完成的闭包。 官方的例子如下： //需要加@escaping的情况 var completionHandlers: [() -&gt; Void] = [] func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) { completionHandlers.append(completionHandler) } //直接在函数内调用传入的闭包则不需要@escaping func someFunctionWithNonescapingClosure(closure: () -&gt; Void) { closure() } @autoclosure 自动闭包 // customersInLine is [&quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;] func serve(customer customerProvider: () -&gt; String) { print(&quot;Now serving \\(customerProvider())!&quot;) } serve(customer: { customersInLine.remove(at: 0) } ) // Prints &quot;Now serving Alex!&quot; 如上代码所示，我们加入一个返回类型为String的闭包，需要在外面加上{}，为了书写方便， 加上@autoclosure关键字，那么这个对{}就可以省略了。 // customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;] func serve(customer customerProvider: @autoclosure () -&gt; String) { print(&quot;Now serving \\(customerProvider())!&quot;) } serve(customer: customersInLine.remove(at: 0)) // Prints &quot;Now serving Ewa!&quot; 编译器会帮我们标记这行代码为闭包，这段代码不会马上被调用，而是当成闭包在函数里调用的时候才被调用。 参考英语原文： https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94 ","link":"https://blog.xioayee.top/post/2016-11-06-closures/"},{"title":"Swift 3.0之类和结构体","content":"写在前面 最近在学swift 3.0，主要看的是苹果的官方文档，这里只是根据自己看官方文档的理解所做的一些记录，不是完整的翻译，希望也对你有所帮助。 类和结构体区别 Swift的类和结构体具有以下相同的特点： 可以定义属性来保存值 可以定义方法来提供功能 可以定义下标来使用他们的值 可以定义初始化器来配置他们的初始化状态 可以在默认的实现上扩展他们的功能 遵从协议来提供标准的功能 类具有结构体没有的额外的功能： 继承允许某一个类继承另外一个类的特性 类型转换允许你检查并在运行时解释一个类实例的类型 析构器允许释放所有该类已经赋值的实例资源 引用计数允许多个引用一个类的实例 结构体一般来说赋值的时候是直接拷贝的，没有使用引用计数的机制。 符号定义 下面是一个定义结构体和类的例子： struct Resolution { var width = 0 var height = 0 } class VideoMode { var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String? } 结构体初始化的时候可以直接 let vga = Resolution(width: 640, height: 480) 这点和类不一样，类没有默认的逐个成员的初始化器。 结构体和枚举是值类型 let hd = Resolution(width: 1920, height: 1080) var cinema = hd 再赋值 cinema.width = 2048 结果 print(&quot;cinema is now \\(cinema.width) pixels wide&quot;) // Prints &quot;cinema is now 2048 pixels wide&quot; 然而hd.width还是1920 print(&quot;hd is still \\(hd.width) pixels wide&quot;) // Prints &quot;hd is still 1920 pixels wide&quot; 可见赋值过程是做了一次深度拷贝。 枚举也是具有同样的行为, 如以下例子，rememberedDirection的值并没有改变： enum CompassPoint { case north, south, east, west } var currentDirection = CompassPoint.west let rememberedDirection = currentDirection currentDirection = .east if rememberedDirection == .west { print(&quot;The remembered direction is still .west&quot;) } // Prints &quot;The remembered direction is still .west&quot; 类是引用类型 例如： let tenEighty = VideoMode() tenEighty.resolution = hd tenEighty.interlaced = true tenEighty.name = &quot;1080i&quot; tenEighty.frameRate = 25.0 进行赋值引用 let alsoTenEighty = tenEighty alsoTenEighty.frameRate = 30.0 结果 print(&quot;The frameRate property of tenEighty is now \\(tenEighty.frameRate)&quot;) // Prints &quot;The frameRate property of tenEighty is now 30.0&quot; 标识符 完全相同（===） 不完全相同（!===） if tenEighty === alsoTenEighty { print(&quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;) } // Prints &quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot; 完全相同（=）和等于（）是不一样的： 完全相同意思是两个类类型的常量或者变量指向完全相同的类实例 等于意思是两个实例被认为值相同或者相等, 可以自行定义==操作符来进行判断两个实例在某种意义上是相等的 选择使用类和结构体 由于结构体的实例一般是值传递，而类实例一般是引用传递，因此你需要根据实际情况来考虑应该定义一个类还是结构体. 如有以下一种或多仲情况使用结构体： 结构体主要的目的是封装少量的相关性简单数据值 在结构体的实例赋值或者传递的时候，需要考虑到封装好的值会被拷贝而不是引用是否是合理的 任何保存于结构体的属性都是值类型的，他们也是期望被赋值或者传递时是拷贝而不是引用 结构体不需要从其他存在的类型继承属性或者行为 看看几个使用结构体恰当的例子： 几何图形的大小，可以封装width和height属性，都是Double类型 指向连续序列范围的方法，可以封装start和length属性，都是Int类型 一个在3D坐标系统的点， 可以封装x, y和z属性，都是Double类型 其他的情况请定义类并创建类实例，管理和传递都使用引用。 在实践中，大部分的自定义数据结构都是使用类居多，很少使用结构体。 String、Array和Dictionary的赋值和拷贝行为 String, Array和 Dictionary都是结构体，因此赋值直接是拷贝，而NSString, NSArray 和NSDictionary则是类，所以是使用引用的方式。 参考英语原文： https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID82 ","link":"https://blog.xioayee.top/post/2016-11-02-swift-classes-and-structures/"},{"title":"迁移到Swift 3.0之@discardableResult","content":"在Swift 2.x的时候，带返回的方法我们如果在调用的时候后面使用到返回的参数，编译器不会有任何的警告，想要编译器给出警告的话需要自己在方法前面添加属性@warn_unused_result, 如 @warn_unused_result func doSomething() -&gt; Bool { return true } 这时候调用这个方法没有使用返回参数的情况下编译器就会给出警告： Result of call to 'doSomething()' is unused 到了 Swift 3.0 我们不需要这样写了，默认情况下编译器就是会去检查返回参数是否有被使用，没有的话就会给出警告。如果你不想要这个警告，可以自己手动加上 @discardableResult，如： @discardableResult func doSomething() -&gt; Bool { return true } 这样一来一切又恢复正常了。 参考: http://useyourloaf.com/blog/swift-3-warning-of-unused-result/ ","link":"https://blog.xioayee.top/post/2016-10-25-swift3-migration-unused-result/"},{"title":"iOS进阶之编写弹性动画","content":"前言 之前在iOS开发干货 第1期中提到过一个挺有意思的数字转变动画NumberMorphView , 如下图： 我将通过几篇文章对这个开源库做一些分析，当然，这篇文章不会对它做全面的解析，而是利用这个库的一些技术概念来做一些简单的示例，也算是一个引子，后面会抽时间再写一篇对这个库的代码分析，敬请期待。 要做些什么 我们将会使用CADisplayLink + CAShapeLayer + UIBezierPath结合制作一个毫秒级的画圆动画，不同的是，这个动画具有弹性效果，下面先来看看制作的效果： 开始 准备工作 先新建一个Single View Application项目，在项目中添加类RRCircleAnimationView，继承于UIView。 打开Main.storyboard，将唯一的一个ViewController的view custom class修改为RRCircleAnimationView。 至此，准备工作已经完成。 动手来画个圆 先来个简单任务，我们来实现画圆动画。 第一步，为RRCircleAnimationView添加属性： @implementation RRCircleAnimationView { CADisplayLink *_displayLink; // CADisplayLink可以确保系统渲染每一帧的时候我们的方法都被调用, 从而保证了动画的流畅性，毫秒级动画就靠他。 UIBezierPath *_path; // 用于创建基于矢量的路径 CGPoint _beginPoint; // 开始触摸位置 CGPoint _endPoint; // 触摸结束的位置 CAShapeLayer *_shapeLayer; // 可以结合UIBezierPath进行绘画 } 接着初始化实例变量，由于我们用的是storyboard进行加载，所以可以在awakeFromNib方法里面初始化 // 注意这里我们是直接从xib加载当前view。 - (void)awakeFromNib { _shapeLayer = [CAShapeLayer layer]; [self.layer addSublayer:_shapeLayer]; _shapeLayer.fillColor = [UIColor colorWithRed:0.400 green:0.400 blue:1.000 alpha:1.000].CGColor; _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(updateFrame)]; [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; } 接下来实现上面CADisplayLink要不停调用的updateFrame方法，我们在此方法内不断地画圆。 - (void)updateFrame { // 画圆 _path = [UIBezierPath bezierPathWithArcCenter:_beginPoint radius:[self getRadius] startAngle:0 endAngle:M_PI*2 clockwise:YES]; _shapeLayer.path = _path.CGPath; } 上面我们用开始触摸的点的位置作为圆心的位置，再根据特定的半径进行绘制一个圆，这个半径是根据我们触摸的开始点和结束点进行计算出来的，开始触摸点到结束点的距离就是这个圆的半径。 我们先把触摸的起始和结束点给找到： - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { UITouch *touch = [touches anyObject]; CGPoint point = [touch locationInView:self]; _beginPoint = point; _endPoint = point; } - (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { UITouch *touch = [touches anyObject]; CGPoint point = [touch locationInView:self]; _endPoint = point; } 最后计算用上我们中学的数学知识，根据两点坐标距离公式 可以得到我们起始和结束两点的距离，也就是圆的半径是： - (CGFloat)getRadius { CGFloat result = sqrt(pow(_endPoint.x - _beginPoint.x, 2) + pow(_endPoint.y - _beginPoint.y, 2)); return result; } 到这里画圆动画完成。 加入弹性效果 上面只是的画圆动画看起来是没什么问题了，不过总感觉缺少动感，接下来我们来帮他加入些活力！ 添加一下成员变量到RRCircleAnimationView类中。 BOOL _isTouchEnd; // 触摸结束标志 int _currentFrame; // 当前的帧数 在- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event方法内添加以下代码： _isTouchEnd = NO; //重置触摸状态 _currentFrame = 1; //重置当前的帧数 添加以下方法： - (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { _isTouchEnd = YES; //触摸结束，更新触摸状态 } 将方法- (CGFloat)getRadius修改如下： - (CGFloat)getRadius { CGFloat result = sqrt(pow(_endPoint.x-_beginPoint.x, 2)+pow(_endPoint.y-_beginPoint.y, 2)); if (_isTouchEnd) { CGFloat animationDuration = 1.0; // 弹簧动画持续的时间 int maxFrames = animationDuration / _displayLink.duration; _currentFrame++; if (_currentFrame &lt;= maxFrames) { CGFloat factor = [self getSpringInterpolation:(CGFloat)(_currentFrame) / (CGFloat)(maxFrames)]; //根据公式计算出弹簧因子 return MAX_RADIUS + (result - MAX_RADIUS) * factor; // 根据弹簧因子计算当前帧的圆半径 }else { return MAX_RADIUS; } } return result; } 最后加入神奇的公式： - (CGFloat)getSpringInterpolation:(CGFloat)x { CGFloat tension = 0.3; // 张力系数 return pow(2, -10 * x) * sin((x - tension / 4) * (2 * M_PI) / tension); } 这个公式用数学符号表达出来是： 可以用Mac OS X自带的软件叫Grapher画出此函数的的图像，如下图： 这个函数的作用其实就是通过x值，也就是当前帧数除以允许的最大帧数。 (CGFloat)(_currentFrame) / (CGFloat)(maxFrames) 因此，x的值的范围也就是(0, 1]。 我们所要的动画效果是把圆拉大到超过或者小于设定的目标半径MAX_RADIUS时，需要一个弹性动画逐渐回到设定好的目标半径。 回头再看一下实时计算动画半径的公式： MAX_RADIUS + (result - MAX_RADIUS) * factor 为了让x = 1的时候，半径 = MAX_RADIUS，所以这时factor就应该为0，也就是f(1) = 0。 再看看刚才的函数图像，在x = 0到1之前振动，随着x的增加振幅逐渐减少，当x = 1的时候，y值为0。 最后 这篇文章讲述了如何自己实现具有弹性的帧动画，如果能理解好这种动画制作原理，对动画效果开发是很有帮助的，后面有时间会继续写其他的一些动画制作的方法，实现更多的动画效果。 差点忘了说了，目前这个动画已经放到github上面，传送门：RRongAnimation The End ","link":"https://blog.xioayee.top/post/2016-08-13-spring-circle-animation/"},{"title":"三分钟编写一款Xcode插件","content":"写在前面 从事iOS开发也比较长时间了，起初的时候用了一些Xcode插件之后感觉确实对开发帮助挺大，后来开始对Xcode插件开发感兴趣了，于是先后制作了AMMethod2Implement, AMAppExportToIPA 和 AMLocalizedStringBuilder 这三款Xcode插件，这些都是在长期使用Xcode开发中萌发出的想法，后来经过研究开发出来的。现在很开心看到越来越多的人开始在开发Xcode插件，很多很有想法的插件开发出来了。同时我相信还有很多人对Xcode插件开发很感兴趣，但是却无从下手，于是有了这一篇文章。 如何开发 插件开发用到各种各样的技术，不是一篇文章可以说得完全的，这篇文章只能算是一个引子，所用到的是最简答的技术进行开发Xcode插件，而这种方法适合的也只是某种特定的场景：在Xcode中选中代码后可以对这些代码进行处理。 开始 效果预览 首先，我们来看一下完成的效果，在Xcode中选择一段要注释的代码，然后点击右键 Services -&gt; Comment Selected Text，我们的插件自动将这段代码用 /* */ 注释掉，如下面演示图片所示。 动手制作 在 应用程序 中打开系统自带的 Automator 应用，在选取文稿类型中选择服务后点击选取按钮。 左侧的 资源库 中选中实用工具，并在右侧列表拉到底部双击选择 运行shell脚本。 按下图所示进行修改： 完成以上步骤后点击保存名为Comment Selected Text，至此，插件已经制作完成，现在打开Xcode的项目，在代码编辑界面选中一段代码，然后点击右键选择Services-&gt;Comment Selected Text，选中的代码自己被注释掉。 我已经把这个workflow文件保存到github上，你可以到这个地址下载：https://github.com/MellongLau/workflow-xcode-plugin 最后 今天介绍的是最简单实用的Xcode插件开发的方法，值得一提的是这个方法在其他的文本编辑器中也可以用，所以这个方法具有普遍的实用性。 如果这篇文章对你有帮助，请分享给更多人知道，转载请注明出处。 The End ","link":"https://blog.xioayee.top/post/2016-05-25-create-xcode-plugin-in-three-minutes/"},{"title":"iOS开发干货 第2期","content":" Realm 一款号称替代Core Data和SQLite的移动端数据库。 LLBootstrapButton Bootstrap 3.0扁平化风格按钮，一句代码调用。 3. RRongAnimation 几个随机动画示例。 4. SAConfettiView 五彩纸屑飘落动画。 5. XXNibBridge 以前做项目的时候也写过类似的在xib中绑定其他xib的控件，不过没有XXNibBridge实现的这么优雅。 6. TGLParallaxCarousel 一个轻量级的3D线性图片轮换控件。 The End ","link":"https://blog.xioayee.top/post/2016-05-17-library-share/"},{"title":"iOS开发干货 第1期","content":"写在前面 在网上看到很多类似的iOS开源库定期分享类文章，觉得非常实用，其实，我自己平时在开发中也不时看到有很不错的资源，但是经常是没有用到就没记录下来，后来想用的时候就可能想不起来找不到了，因此现在也用这种形式记下来方便自己查找，同时也分享给大家。 开源库 GPUImage 2 鼎鼎大名的图像和视频处理开源库GPUImage第二代，之前是用object-c写的，这一次全部使用swift改写，因此GPUImage 2已经支持Linux和将来所有支持swift的平台。 MRProgress 类似SVProgressHUD的进度条和状态提示控件集，看厌了SVProgressHUD的样式的话，不妨可以试一试这一款。 UIImageColors iTunes风格的图片颜色拾取器，它能提取图片里面最主要的和最突出的颜色。 LLSlideMenu 一个弹性侧滑菜单，效果如下图： NumberMorphView 一个挺有意思的数字转变动画。 AMAnimatedNumber 另外一种风格的数字动画。 BTNavigationDropdownMenu 一款比较实用的导航栏下拉菜单控件。 The End ","link":"https://blog.xioayee.top/post/2016-04-30-library-share/"},{"title":"iOS开发大神必备的Xcode插件","content":"写在前面 工欲善其事，必先利其器，iOS开发中不仅要学会Xcode的基本操作，而且还得学会一些Xcode的使用技巧，如掌握常用的快捷键等，还有就是今天要说到的Xcode插件，下面我就为大家介绍几款开发中比较常用的Xcode插件（此处应有掌声）。 插件推荐 1. AMAppExportToIPA 简介： AMAppExportToIPA 是一款可以让你在Xcode的project navigator界面中直接右键点击xxx.app -&gt; Export IPA就可以生成对应的IPA文件的Xcode插件。 演示图片： Github地址：https://github.com/MellongLau/AMAppExportToIPA-Xcode-Plugin 2. HOStringSense 简介： 可以完美编辑正则表达式，多行文本，HTML等字符串，还提供字符串长度快速提示。 演示图片： Github地址：https://github.com/holtwick/HOStringSense-for-Xcode 3. MCLog 简介： MCLog 是一款可以让你轻松过滤Xcode控制台日志输出的Xcode插件。虽然目前已经可以搜索到控制台日志输出的文本，但是仍然还有大量你不感兴趣的日志。MCLog是对此问题的一个简单解决方案。使用简单的字符串来过滤控制台，并显示你真正想看到的日志。 演示图片： Github地址：https://github.com/yuhua-chen/MCLog 4. AMMethod2Implement 简介： 可以自动的将.h或者.m .mm里边需要写入的方法自动填充进来。可以选择要导入的方法，然后按 Ctrl+A 或者 Edit &gt; AMMethod2Implement &gt; Implement Method.就会自动填充方法.也可以自行设置快捷键。 目前版本支持h文件声明方法自动生成实现，m或者mm文件已写好的方法生成方法声明到h文件， extern NSString * const， @select(method:) 和 [self methodName] 实现代码生成。 演示图片： Github地址：https://github.com/MellongLau/AMMethod2Implement 5. Auto-Importer 简介： 可以搜索和自动导入头文件的一款Xcode插件。 演示图片： Github地址：https://github.com/citrusbyte/Auto-Importer-for-Xcode 6. ColorSense 简介： 具有可以用颜色选择面板直接插入颜色代码和颜色代码显示颜色预览功能。 Github地址：https://github.com/omz/ColorSense-for-Xcode 7. VVDocumenter 简介： VVDocumenter是一款输入///就会自动生成javadoc风格注释的Xcode插件。 演示图片： Github地址：https://github.com/onevcat/VVDocumenter-Xcode 8. AMLocalizedStringBuilder 简介： AMLocalizedStringBuilder 是可以帮助你将语言本地化文件Localizable.strings生成object-c的类AMLocalizedString的Xcode插件，这样可以直接使用R_String.am_&lt;#你的本地化字符串key#&gt;获取对应key的值，还可以随时点击Alt或Option按键查看当前字符串的值。 演示图片： Github地址：https://github.com/MellongLau/AMLocalizedStringBuilder-Xcode-Plugin 9. R.swift 简介： 类似AMLocalizedStringBuilder，不过是swift版本的，功能也更丰富，不仅支持Localized strings映射，还支持其他资源的映射，支持的列表如下： Images Custom fonts Resource files Colors Localized strings Storyboards Segues Nibs Reusable cells 演示图片： Github地址：https://github.com/mac-cain13/R.swift 10. CopyIssue 简介： 方便你搜索的任何错误或警告的问题，可以复制完整的问题描述，或者可以自动打开你的默认浏览器并通过Google（默认快捷⇧⌥G）或Stackoverflow（默认快捷⇧⌥S）搜索你选择的问题。 演示图片： Github地址：https://github.com/hanton/CopyIssue-Xcode-Plugin 如何安装 安装方法目前有两种： 从github下载源代码进行安装 $ git clone git@github.com:插件地址 打开插件项目运行，运行成功后程序会自动把插件文件拷贝到这个路径下： ~/Library/Application Support/Developer/Shared/Xcode/Plug-ins。 重新启动Xcode使插件生效。 通过Xcode插件管理器 Alcatraz 进行安装，安装完成后也要重新启动Xcode使插件生效。 最后 随着Xcode的发展和iOS开发的红火，现在Xcode插件越来越多了，插件越来越多当然是好事，毕竟选择就更多，功能也更丰富了，不过，安装太多插件容易造成Xcode运行不稳定，因此，安装插件还是要根据自身需求选择稳定性比较好的插件（此处应有掌声）。 The End ","link":"https://blog.xioayee.top/post/2016-04-30-xcode-plugin/"},{"title":"神器Docker入门之安装配置篇","content":" 写在前面 Docker近几年来火得不得了，作为一名IT人如果不知道Docker是什么就有点out了，确实，我也out了，这几天才知道的Docker。连忙网上一顿学习，才知道Docker是什么(⊙﹏⊙)b，如果你也不知道什么是Docker，也想试一试，那么这篇文章非常值得你一看。 Docker是什么？ Docker是何方神圣，为何如此之受欢迎呢？ 拿现实世界中货物的运输作类比, 为了解决各种型号规格尺寸的货物在各种运输工具上进行运输的问题, 我们发明了集装箱。 Docker每个镜像相当于一个集装箱，当我们把配置好的环境交给客户时，我们只需要把镜像发给客户，客户不用再做环境配置的工作，也不用担心使用起来会和我们这边的环境不一样。其实这个也和虚拟机类似，不过虚拟机运行起来占用资源厉害，启动速度慢，镜像体积也比较大。 看到这里还是不明白，不用着急，继续往下看。 Docker可以做什么？ Docker可以用来做演示，可以做环境备份，也可以把部署环境发给客户，对于我来说，最有用的就是利用Docker可以快速运行不同的软件进行学习和尝试。例如我想试试最新版本的WordPress，但是我又不想花一大堆时间去配置数据库，搭建php运行环境等等，这时用Docker的话，只要几条命令，花上几分钟（主要是下载镜像比较花时间）就可以用上WordPress，回想起以前第一次玩WordPress配置环境的时候是多么痛苦... 安装配置Docker Mac OS X安装Docker非常简单，直接到Docker官网下载他家的 Docker Toolbox ，根据安装提示安装即可，这里也有windows版的，不过遗憾的是目前Mac版和windows版都是基于虚拟机实现的，不用虚拟机的话只能Linux才可以做到。 安装完毕后点击 Launchpad，在里面打开Docker Quickstart Terminal 即可启动Docker，使用Kitematic也可以打开Docker，这是Docker的图形化管理界面，用起来也挺方便的。 运行第一个容器 Hello World 安装配置好之后，我们已经迫不及待要运行一下容器来试试了，对于程序员来说，当然第一个程序应该是hello world了，官方已经为我们做了一个hello world的镜像，只需要一句命令就可以跑起来： $ docker run hello-world 输出信息如下： $ docker run hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 535020c3e8ad: Pull complete af340544ed62: Pull complete Digest: sha256:a68868bfe696c00866942e8f5ca39e3e31b79c1e50feaee4ce5e28df2f051d5c Status: Downloaded newer image for hello-world:latest Hello from Docker. This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker Engine CLI client contacted the Docker Engine daemon. 2. The Docker Engine daemon pulled the &quot;hello-world&quot; image from the Docker Hub. 3. The Docker Engine daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker Engine daemon streamed that output to the Docker Engine CLI client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker Hub account: https://hub.docker.com For more examples and ideas, visit: https://docs.docker.com/userguide/ 看到这些信息也证明你已经成功安装了Docker。 Ubuntu 眼尖的应该发现输出信息里面有一句 $ docker run -it ubuntu bash 没错，这句命令就是运行一个Ubuntu容器，只要这一句命令Docker就自动会从Docker hub上下载最新的Ubuntu镜像到本地并且运行。然而，由于Docker的服务器在大洋彼岸，下载起来确实是比较慢，后面的文字会分享如何使用国内的镜像服务器进行下载。 最后 这篇文章主要是介绍Docker的安装配置，后面的文章会详细介绍如何使用国内镜像，运行WordPress、GitLab和Ghost等软件，如对Docker有兴趣请关注后续内容。 作者也是第一次玩Docker，文中难免有错误之处，望各位多予指正，不胜感激。 参考 http://blog.csdn.net/colorant/article/details/20608157 https://docs.docker.com/mac/step_one/ The End. ","link":"https://blog.xioayee.top/post/2016-04-28-docker-setup/"},{"title":"奇幻森林，一个适合大人的童话故事","content":" 这个周末也去把奇幻森林看了，去之前是看了预告片和网上的评价才决定去的，所以一开始是知道整个电影除了小孩之外，其他都是电脑CG效果，虽然已经有这个预期，但是去到还是被震撼到了，整个电影的画面看不出是电脑做出来的，所有东西都是那么真实。 这电影确实比较适合成年人看，暴力，恐怖和整场基本都处于暗黑的气氛，现场有小朋友吓到哭着喊要回家。电影的幽默元素不是很多，有零星的笑点，主要是巴鲁熊出现之后才比较欢乐，整场感觉压抑气氛居多，这一点上和疯狂动物城有比较大的区别。 剧情较弱？是动物世界纪录片？ 看了这个电影后，我又看了下网上对这出电影的评价，普遍都说这出电影画面逼真但剧情比较弱。然而我看下来却没有这个感觉，这电影给我感觉是紧张刺激，有感动，有欢乐，剧情很紧凑，这已经够了，当然，不可否认相比之下画面给人的印象更深，从森林到众多的动物确实有点动物世界的感觉。 大象的神圣，巴鲁熊的幽默，大蛇的惊悚，老虎的凶恶... 总的来说，这是一出很不错的电影，用精彩的电脑特效来讲述一个童话故事，看完回味无穷，甚是享受。 ","link":"https://blog.xioayee.top/post/2016-04-23-magic-story/"},{"title":"Macbook SSD硬盘空间不够用了？来个Xcode大瘦身吧！","content":"写在前面 最近突然发现我的128G SSD硬盘只剩下可怜的8G多，剩下这么少的一点空间连Xcode都无法更新。怎么办呢？如果升级硬盘的话，第一要花钱，毕竟SSD硬盘还是不便宜，第二是升级比较麻烦，要拆机和迁移系统什么的特别花时间精力，老了真不愿瞎折腾了，只能想办法能不能清除点空间来。 寻找大块头 首先想到的就是能不能删掉安装在SSD硬盘里面平时不用或者很少用到软件，可是仔细一看发现每个软件都是精心挑选，辛辛苦苦安装上去的，看来看去都不舍得卸载掉；好吧，那就看看能不能清掉下载文件夹里面某些没用的文件，最后删来删去也就删了几百兆，后来才想起来好像之前硬盘空间紧张已经清理过一次了… 继续在硬盘里寻找可以清除的文件，不久大发现来了，用户文件夹下的 资源库 这个文件夹特别大，进到这个文件夹发现大块头是 Developer 文件夹，原来是Xcode耗费了我那么多空间！ 开始清理 下面这几个是我主要清理的文件夹： 这里放的是连接真机生成的文件，可以全部删掉或者把不常用的版本删掉，再次连接设备会自动生成 ~/Library/Developer/Xcode/iOS DeviceSupport app打包生成的文件，可以删掉不需要的项目打包文件 ~/Library/Developer/Xcode/Archives 项目的索引文件等，可以全部删除，或者删除不常用的项目，再次打开项目会自动生成 ~/Library/Developer/Xcode/DerivedData 经过清理，硬盘可用空间一下子变成了28G多，整整多了20多G！ 最后 如果你也和我一样空间不够又不想升级硬盘，赶紧看看你的 ~/Library/Developer/Xcode/ 文件夹，如无意外应该也有惊喜。 The End. ","link":"https://blog.xioayee.top/post/2016-04-21-clean-mac-ssd/"},{"title":"强大的Git客户端：SourceTree插件开发指南","content":"SourceTree是什么？ 简单来说SourceTree是一款免费git图形化操作软件，功能很全，使用起来非常方便，相信不少开发者已经在使用这款软件。 具体还是来看看网上的介绍： SourceTree是Windows 和Mac OS X 下免费的Git 和Hg 客户端，拥有可视化界面，容易上手操作。 同时它也是Mercurial和Subversion版本控制系统工具。 支持创建、提交、clone、push、pull 和merge等操作。 简单说一下我的感受，一开始使用git的时候，基本上都是直接敲命令的，（没有好的软件，只能自我安慰使用命令行对学习git更有利，苦逼的程序猿），也不知道有什么GUI软件比较好用，直到后来知道了SourceTree，使用上一段时间就彻底离不开它了，功能强大，界面漂亮，用起来顺手，跨平台，还持续更新，最重要的是免费，你没看错，是免费（重要事情说两遍就可以了），有中文版本（虽然我不喜欢用中文版，目前还是用的英文版，原因是中文版看不出来对应的git命令是什么，个人建议大家也用英文版）。 郑重声明一下，这篇文章不是软文。（如果SourceTree的作者看到这篇文章觉得不错的话…，可以和我联系，我这里可以接收美金，怎么联系到我？可以点击查看我的个人信息，微信，主页，邮箱都可以，好吧，我承认我想多了）。 今天所说的插件开发，实际上是SourceTree一个叫Custom Action的功能，SourceTree从v1.3开始就增加了这个功能，这个功能可以让我们可以添加自定义的扩展动作，也就是我们经常说的插件，下面就用实际例子来让大家看看在实际中可以做些什么。 开始动手 加入Open In Sublime Text 2功能 举第一个栗子，我们可以使用Sublime Text 2打开当前选中的文件。 以下下步骤以英文版为准，中文版的请自行翻译… Custom Actions 页面点击Add添加一个名为 Open In Sublime Text 2 的动作，右边的编辑框可以添加快捷键，接着拷贝下面代码到 Script to run 编辑框中 /Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl Parameters添加 $FILE， 最后点击OK保存。 添加好的界面是这样子的： 至此，我们已经成功实现了这个功能。使用的时候只要选中要打开的文件，点击右键 Custom Actions &gt; Open In Sublime Text 2 即可。 加入Open Workspace和Open Xcodeproj功能 接下来，我们再来做一个稍微复杂点的栗子。 每次打开SourceTree的仓库列表或者进入仓库的时候，如果我们要打开这个仓库的项目文件，还得先去到这个项目的文件夹找到后再打开，如果有一个功能可以直接点击一个按钮就可以自动找到并打开这个仓库里面所有的xcworkspace或者xcodeproj文件就好了，值得庆幸的事，我们可以做到这样的插件，具体做法如下： 新建一个自定义动作分别填入下面内容 打开xcworkspace文件 字段名 内容 Menu Caption Open Workspace Script to run /bin/bash Parameters /Users/.../open_xcode_project.sh $REPO xcworkspace 再新建建一个自定义动作分别填入下面内容 打开xcodeproj文件 字段名 内容 Menu Caption Open Xcodeproj Script to run /bin/bash Parameters /Users/.../open_xcode_project.sh $REPO xcodeproj 新建一个名为open_xcode_project.sh文件，路径和上面的路径一致：/Users/.../open_xcode_project.sh，路径是你自己定的，不要和我一样也加...，内容如下： #仓库路径 REPO_PATH=$1 #文件的类型 OPEN_TYPE=$2 #判断打开项目文件的类型，根据类型筛选出项目文件路径 if [ $OPEN_TYPE = &quot;xcodeproj&quot; ]; then LIST=`find $REPO_PATH -name &quot;*.xcodeproj&quot; | grep -v &quot;Pods.xcodeproj&quot;` else LIST=`find $REPO_PATH -name &quot;*.xcworkspace&quot; | grep -v &quot;.xcodeproj/project.xcworkspace&quot;` fi for ITEM in $LIST do #打开项目文件 open $ITEM done 上面用到的 open_xcode_project.sh 文件我已经上传到github，传送门：SourceTree Custom Action 完成上面这几步后，在仓库右键就可以看到新添加的两个功能，如下图，点击对应的功能程序就会自动打开该仓库下的项目文件，不得不说太方便了！满满的成就感有没有！ 不难看出，这个插件主要是通过shell脚本来完成，把仓库的路径和打开文件的类型传给脚本来进行处理，脚本过滤出目标的文件路径并依此使用默认的软件（也就是Xcode）来打开项目文件。 最后 这篇文章只是抛砖引玉，你可以做到更多更棒的功能，只要你对shell命令足够熟悉，当然，想法最重要，如果有好的想法欢迎你共享出来，只有分享才能相互进步。 另外，我建了一个SourceTree的Custom Action github仓库：SourceTree Custom Action，希望有志之士（说的就是你）一起来维护，来给我pull request吧。希望看到不久的将来我的SourceTree的Custom Action菜单满满的都是各种各样的功能。 The End. ","link":"https://blog.xioayee.top/post/2016-04-20-source-tree-custom-action/"},{"title":"Xcode自动填充方法插件：AMMethod2Implement","content":" 简介 AMMethod2Implement是一款可以自动的将.h或者.m .mm里边需要写入的方法自动填充进来的Xcode插件。使用过程中可以选择要导入的方法，然后按 Ctrl+A 或者点击Xcode顶部的菜单 Edit &gt; AMMethod2Implement &gt; Implement Method 就会自动生成填充好选中的方法，快捷键默认是Ctrl+A，也可以自行设置快捷键。 目前版本支持h文件声明方法自动生成实现，m或者mm文件已写好的方法生成方法声明到h文件， extern NSString * const， @select(method:) 和 [self methodName] 实现代码生成，暂时只支持object-c语言，不支持swift。 使用演示 安装方法 安装方法目前有两种： 从github下载源代码进行安装 $ git clone git@github.com:MellongLau/AMMethod2Implement.git 打开AMMethod2Implement项目运行，运行成功后程序会自动把插件文件拷贝到这个路径下： ~/Library/Application Support/Developer/Shared/Xcode/Plug-ins。 重新启动Xcode使插件生效。 通过Xcode插件管理器 Alcatraz 进行安装，安装完成后也要重新启动Xcode使插件生效。 安装后无法使用怎么办 如果安装后出现无法使用的情况，可以尝试在终端运行一下命令： curl https://raw.githubusercontent.com/cielpy/RPAXU/master/refreshPluginsAfterXcodeUpgrading.sh | sh 运行完重启Xcode再试。 插件地址： https://github.com/MellongLau/AMMethod2Implement ","link":"https://blog.xioayee.top/post/2016-04-19-xcode-plugin-AMMethod2Implement/"},{"title":"修复ios8 gps关闭无法跳转到系统设置页面问题","content":"之前一直使用 [[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;prefs://&quot;]]; 方便用户点击按钮后跳转到系统设置页面，最近发现有的机器无法跳转成功。 原来是ios8打后用了不同的url string进行跳转，修复兼容代码如下： double version = [[UIDevice currentDevice].systemVersion doubleValue];//判定系统版本。 if(version &gt;= 8.0f){ [[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]]; }else { [[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;prefs://&quot;]]; } ","link":"https://blog.xioayee.top/post/2016-04-19-setting-page-link/"},{"title":"iOS为你的数字添加动画：AMAnimatedNumber控件","content":"效果预览 安装 从CocoaPods安装 CocoaPods 推荐用CocoaPods来添加管理AMAnimatedNumber控件到你的项目中. 添加到 Podfile 文件中. pod &quot;AMAnimatedNumber&quot;, &quot;~&gt; 0.0.1&quot; 使用pod命令 pod install 进行安装. 导入 AMAnimatedNumber： #import &lt;AMAnimatedNumber.h&gt;. 使用方法 初始化: AMAnimatedNumber *animateNumber = [[AMAnimatedNumber alloc] initWithFrame:CGRectMake(0, 0, 300, 35)]; [self.view addSubview:animateNumber]; 更改数字和样式 [animateNumber setTextFont:[UIFont boldSystemFontOfSize:28]]; [animateNumber setTextColor:[UIColor brownColor]]; [animateNumber setNumbers:@&quot;$ 89,572,234.32&quot; animated:YES]; 控件的源码地址： https://github.com/MellongLau/AMAnimatedNumber ","link":"https://blog.xioayee.top/post/2016-04-10-iOS-AMAnimatedNumber-guide/"},{"title":"让多语言本地化变得更简单的Xcode插件——AMLocalizedStringBuilder","content":"写在前面 一直就想写一款多语言本地化的插件，虽然网上也有很多这种类型的插件可供选择，但是总感觉用起来不够方便。 一次偶然的机会接触到Android开发，觉得Android开发中直接可以使用R.string直接获取到定义在xml里面的文字资源，感觉很方便，于是就有个想法，Xcode也能否做到这样，最后经过研究开发出了这款插件。 AMLocalizedStringBuilder是什么 AMLocalizedStringBuilder 是可以帮助你将语言本地化文件Localizable.strings生成object-c的类AMLocalizedString的Xcode插件，这样可以直接使用R_String.am_&lt;#你的本地化字符串key#&gt;获取对应key的值，还可以随时点击Alt或Option按键查看当前字符串的值。 安装方法 安装方法目前有两种： 从github下载源代码进行安装 $ git clone git@github.com:MellongLau/AMLocalizedStringBuilder-Xcode-Plugin.git 打开AMLocalizedStringBuilder项目运行，运行成功后程序会自动把插件文件拷贝到这个路径下： ~/Library/Application Support/Developer/Shared/Xcode/Plug-ins。 重新启动Xcode使插件生效。 通过Xcode插件管理器 Alcatraz 进行安装，安装完成后也要重新启动Xcode使插件生效。 安装后无法使用怎么办 如果安装后出现无法使用的情况，可以尝试在终端运行一下命令： curl https://raw.githubusercontent.com/cielpy/RPAXU/master/refreshPluginsAfterXcodeUpgrading.sh | sh 运行完重启Xcode再试。 如何使用 点击Xcode顶部菜单 Product-&gt;AMLocalizedStringBuilder-&gt;Build Localized String 或者直接用快捷键 ctrl+f 来把Localizable.strings生成为object-c类。 打开你当前项目文件夹，可以找到已经生成好的 AMLocalizedString.h and AMLocalizedString.m 这两个文件，把他们直接拉到项目中添加引用。 在要用到的地方先导入头文件 AMLocalizedString.h， 然后使用R_String.am_&lt;#your_localized_string_key#&gt;来获取对应本地化的文字。 另外，你还可以用快捷键ctrl+cmd+s打开设置窗口，在设置窗口里面选择你要进行转换的Localizable.strings文件。 可以参考以下步骤演示： 插件地址： https://github.com/MellongLau/AMLocalizedStringBuilder-Xcode-Plugin ","link":"https://blog.xioayee.top/post/2016-04-04-rang-ni-duo-yu-yan-ben-di-hua-geng-jian-dan-de-xcodecha-jian-amlocalizedstringbuilder.markd/"},{"title":"一键把.app 输出为 .ipa","content":"一键把.app 输出为 .ipa, 新Xcode插件发布了 AMAppExportToIPA 是一款可以让你在Xcode中的project navigator界面中直接右键点击xxx.app -&gt; Export IPA就可以生产对应的IPA文件的插件，下面是操作演示： 目前这款插件已经可以在Alcatraz中下载到，或者也可以到github自己下载自行编译。 想了解更多信息请点击下面的链接 https://github.com/MellongLau/AMAppExportToIPA-Xcode-Plugin ","link":"https://blog.xioayee.top/post/2016-02-20-jian-ba-dot-app-shu-chu-wei-ipa.markd/"},{"title":"制作树莓派wifi遥控和自动避障小车","content":"写在前面 前几年买了树莓派，当时主要是想用来做客厅多媒体盒，不过实际使用下来有点卡，速度不尽人意。虽然后来换了class10的SD卡速度有点提升，但也很少拿去看电影了，多数时间是用来做下载机。 其实之前也有听说可以做很多有趣的东西，我最感兴趣就是做个遥控小车，一直有这个想法，就是没有实际行动。最近在网上又看到类似的遥控车，突然间又来了兴致，这次决心很大，立即就找了下资料，并且在淘宝上买了配件。趁着周末有时间，花了半天时间组装好了，又花了半天改了程序支持自动避障，还做了个iPad/iPhone的手机端遥控app。自己又是摆道具又是录视频的，忙得不亦乐乎。废话少说，现在进入正题！ 视频效果 这是后来做的加了三路寻轨功能的视频，后面文章会继续介绍： 看不到视频的可以点这个链接跳转到优酷看：https://v.youku.com/v_show/id_XMTI4Nzk0NjMyOA==.html 需要的材料 树莓派小车底盘，这个上淘宝一搜一大堆，我买的四驱的，有带亚克力两层车板。 三种杜邦线，每一种买十条就可以了，我当时怕不够用，每一种都买了20条。 移动电源，这个家里之前有一个飞毛腿的，要买双usb输出的。 树莓派 L298N电机驱动板模块 红外避障模块和超声波测距模块，如果想做避障功能就需要买这个传感器，买两个（开始的时候不知道，我只买了一个红外避障模块...）。 USB无线网卡 上面的花费下来，不计树莓派、USB无线网卡和移动电源，大概花了90元左右。 材料组装 小车底盘 材料到手之后，先组装车底盘，安装说明书把第一层组装好，马达连线见下图，线我是用杜邦线一分为二去接的。 注意走线是上下交叉连接。 与L298N驱动模块连线 模块两边有各有两个out接口分布连接两边马达，四个IN接口连接树莓派的四个GPIO接口，连上后记得自己连接的接口编号就可以，写代码的时候需要。 供电 我使用之前买的移动电源供电，自带有两个USB接口，一个接树莓派，一个接L298N驱动模块。也可以自己买电池盒进行串联供电。 接模块的电源我使用usb线剪的，其中黑线是接地，红线接VCC。 遥控程序 遥控主要是通过树莓派的GPIO设置高低电平信号来控制小车前进、后退、左转、右转和停止，具体可以参考代码和下面GPIO的接口说明。值得注意的是，1对应的树莓派电路板背面焊锡为方形的针脚。 web版 web版可以直接使用王恒的版本： https://github.com/wujiwh/piCar 主要修改自己接的GPIO接口和对应的方向。 iOS版 简单写了iOS客户端，服务端是用王恒的版本改的： RaspiCar 自动避障版 由于只买了一个红外避障模块，于是只能单边避障，这里是代码： #!/user/bin/env python import RPi.GPIO as GPIO GPIO.setmode(GPIO.BOARD) GPIO.setwarnings(False) GPIO.setup(11,GPIO.OUT) GPIO.setup(12,GPIO.OUT) GPIO.setup(15,GPIO.OUT) GPIO.setup(16,GPIO.OUT) GPIO.setup(7,GPIO.IN) def t_stop(): GPIO.output(11, False) GPIO.output(12, False) GPIO.output(15, False) GPIO.output(16, False) def t_down(): GPIO.output(11, True) GPIO.output(12, False) GPIO.output(15, True) GPIO.output(16, False) def t_up(): GPIO.output(11, False) GPIO.output(12, True) GPIO.output(15, False) GPIO.output(16, True) def t_right(): GPIO.output(11, False) GPIO.output(12, True) GPIO.output(15, True) GPIO.output(16, False) def t_left(): GPIO.output(11, True) GPIO.output(12, False) GPIO.output(15, False) GPIO.output(16, True) while True: in_right= GPIO.input(7) if in_right == False: t_left() else: t_up() 最后 完成效果图： ","link":"https://blog.xioayee.top/post/2015-07-12-zhi-zuo-shu-mei-pai-wifiyao-kong-he-zi-dong-bi-zhang-xiao-che.markd/"},{"title":"如何画曲线图","content":"效果： 由左下图可以看到两点之间有两个control point，可以取两点之间的中点的x作为两个control point的x，前一点的y作为control point1的y值，后一点的y作为control point2的y值。 代码： - (void)drawRect:(CGRect)rect { CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetRGBStrokeColor(context,1,0,0,0.6); CGContextSetLineWidth(context, 1); CGContextScaleCTM(context, 1, -1); CGContextTranslateCTM(context, 0, -rect.size.height); NSArray *values = @[@50, @65, @75, @70, @80, @90, @67, @65, @75, @70, @80, @90, @67, @65, @75, @70, @80, @90, @67]; // y值数组 CGFloat space = 10.f; //x坐标间隔 CGFloat startX = 10.f; //x坐标起始点 int i = 0; for (int x = startX; x &lt; rect.size.width-2*startX; x+=space) { if (i &gt;= values.count) { break; } CGFloat currentY = [values[i] floatValue]; if (x == startX) { CGContextMoveToPoint(context, x, currentY); }else{ CGFloat preY = [values[i-1] floatValue]; CGFloat controlPointX = x-5; CGContextAddCurveToPoint(context, controlPointX, preY, controlPointX, currentY, x, currentY); } i++; } CGContextDrawPath(context, kCGPathStroke); } ","link":"https://blog.xioayee.top/post/2015-07-09-ru-he-hua-qu-xian-tu.markd/"},{"title":"如何快速得到数组所有元素累加结果，平均值和最大最小值","content":"开发过程中经常会需要数组求和，平均数和最大最小值，第一想法是遍历数组进行累加或者排序。 其实SDK已经提供了相关的方法，比较特别的是通过KVC实现的，示例代码如下： NSArray *values = @[@72, @78, @75, @70, @72, @73, @77, @78, @75, @70, @72, @73, @87, @78, @75, @70, @72]; NSNumber *avg = [values valueForKeyPath:@&quot;@avg.self&quot;]; NSNumber *sum = [values valueForKeyPath:@&quot;@sum.self&quot;]; NSNumber *max = [values valueForKeyPath:@&quot;@max.self&quot;]; NSNumber *min = [values valueForKeyPath:@&quot;@min.self&quot;]; 更多内容请查看官方文档: https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/CollectionOperators.html ","link":"https://blog.xioayee.top/post/2015-07-08-ru-guo-kuai-su-de-dao-shu-zu-suo-you-yuan-su-lei-jia-jie-guo-huo-ping-jun-zhi.markd/"},{"title":"输出静态库和framework需要注意的事","content":"问题 最近因为项目需要，经常要打包静态库给别人用，同时静态库本身要加入其他同事做好的静态库，在build的时候发现比较多的问题就是提示: Symbol(s) not found for architecture arm64 原因 原因是打包静态库时直接用的时debug环境，而在该环境下默认设置Build Active Architecture Only为YES。 解决 解决的方法有两种： 1.修改编译环境为release，再打包。 2.修改Build Active Architecture Only中debug的值为NO。 到底选择哪种方法，具体还得看需求而定了。 ","link":"https://blog.xioayee.top/post/2015-01-17-shu-chu-jing-tai-ku-he-frameworkxu-yao-zhu-yi-de-shi.markd/"},{"title":"gem install 出现错误 cannot load such file -- openssl","content":"今天想要在cocoapods加入一个库，用pod install后出现这个错误，百思不得其解，上网找了一圈发现，这个问题应该是更新了Mac OS X导致的，解决方法如下： brew install openssl rvm pkg install openssl rvm reinstall [version] 以上命令执行一遍，问题解决。 ","link":"https://blog.xioayee.top/post/2014-05-14-gem-install-rails-chu-xian-cuo-wu-cannot-load-such-file-openssl/"},{"title":"About system volume progress view rotation issue","content":"使用MPVolumeView时 system volume progress view 则不会出现， 不过如果有时想同时出现自己定制的volume bar和 system volume progress view时，这时就不能使用MPVolumeView了，需要自己使用UISlider自定义UI和关联逻辑进行实现。 然而，如果app设定为只是Landscape方向的话，system volume progress view可能就回发生rotation的问题。例如在竖屏的情况下打开app， app自动旋转到landscape方向展示，但是这时使用设备的音量调节按钮进行调节声音，可能会发现system volume progress view显示的方向还是处于竖屏的方向，没有自动旋转为横屏，解决方法如下： 由于app里面虽说大部分只支持横屏，但是，也有需要支持竖屏的情况，如查看pdf。 于是需要在AppDelegate里加入方法： - (NSUInteger)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window { return UIInterfaceOrientationMaskAll; } 支持所有方向，具体支持的方向有ViewController里面的autoRotation方法返回的值决定。 修改xxx-Info.plist文件的Supported interface orientations (iPad) 项，去掉竖直方向的两个参数。只剩下landscape两个方向。 至此问题彻底解决。 ","link":"https://blog.xioayee.top/post/about-system-volume-progress-view-rotation-issue/"},{"title":"Autolayout使用笔记","content":"iOS6开始就引入了autolayout特性，使用autolayout进行自动布局确实方便了很多，下面是autolayout使用的一些心得。 每次设置完Label的text属性后，需要使用 [self setNeedsUpdateConstraints]; [self updateConstraintsIfNeeded]; 这两个方法进行更新布局，接着使用 [self setNeedsLayout]; [self layoutIfNeeded]; 更新控件的frame等属性。 使用以下方法进行计算当前view的最小size： CGFloat height = [self systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height; 计算结束后记得设置当前view的实际高度： self.height = height; ","link":"https://blog.xioayee.top/post/autolayout-shi-yong-bi-ji/"},{"title":"横屏竖屏自适应总结","content":"所有frame的高度和宽度应该通过superview的bounds计算。 xib中的view无法设置auto mask的必须通过代码设，不设定的话有时可以自动适应，但是有时会出现有部分黑屏的情况。 两边都不设置mask则为居中显示。 以下两方法为rotate是自动调用，如果该viewController没有navigationController时，以下两方法可能不被调用，需要自己加入通知中心。 - (void)didRotateFromInterfaceOrientation:(UIInterfaceOrientation)fromInterfaceOrientation 调用此方法时superview.bounds已经改变 - (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration 调用此方法时superview.bounds未改变 获取当前屏幕方向 UIInterfaceOrientation currentOrient = [UIApplication sharedApplication].statusBarOrientation; 判断当前设备是否为4寸屏 #define isIPhone5 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 1136), [[UIScreen mainScreen] currentMode].size) : NO) 3.5与4寸屏高度相差88.f,宽度一样为320.f 自适应横屏一般修改automask的autowidth,导航栏和一般控件主要变化的是宽度，高度也变化的一般是可以tableView和scrollView等。 有时候横屏没有正确自适应一般是superview.bounds未改变，设置subview frame的时机不对。 如果想让某一个ViewController固定某个方向不旋转，方法如下： 修改AppDelegate.m，加入下列代码，其中_enablePortrait为新增的变量，用于判断是否要进行旋转。 - (NSUInteger)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window { if(_enablePortrait) { return UIInterfaceOrientationMaskPortrait; } return UIInterfaceOrientationMaskLandscape | UIInterfaceOrientationMaskPortrait; } 在不需要旋转的viewController中的下列方法中加入以下代码即可。 -(void)viewWillAppear:(BOOL)animated { AppDelegate *delegate = (AppDelegate *)[UIApplicationsharedApplication].delegate; delegate.enablePortrait = YES; } - (void)viewWillDisappear:(BOOL)animated { [super viewWillDisappear:animated]; AppDelegate *delegate = (AppDelegate *)[UIApplicationsharedApplication].delegate; delegate.enablePortrait = NO; } 由于使用pushViewController会导致所进入的视图会根据前一视图的方向显示，所以需要用以下方法hack一下，才能使其自动根据设定的方向旋转。 - (void)updateOrientation { [[UIApplicationsharedApplication] setStatusBarOrientation:UIInterfaceOrientationPortraitanimated:NO]; UIViewController *viewController = [[UIViewControlleralloc] init]; [self presentModalViewController:viewController animated:NO]; [self dismissModalViewControllerAnimated:NO]; [viewController release]; } iOS6旋转发生当时屏幕不旋转的原因可能是： if (SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@&quot;6.0&quot;)) { self.window.rootViewController = gameNavController; }else { [self.window addSubview:gameNavController.view]; } 在应用中有时需要制定某些页面是Portrait或者landscape，这时需要在info.plist文件加入对这些方向的支持。 如果window的rootViewController是NavigationController则需继承该类写入： //iOS6以下版本 - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation { return UIInterfaceOrientationIsLandscape(toInterfaceOrientation); } //iOS6及以上版本 - (BOOL)shouldAutorotate { return YES; } - (NSUInteger)supportedInterfaceOrientations { return UIInterfaceOrientationMaskLandscape; } 由此则全局默认情况下只支持landscape。 注意：navigationController在其子类中指定，在push进去的viewController指定则是无效。 有效的情况为使用presentModalViewController或者其他形式的present，在present的viewController中重写这三个方法，可以限制其当前的方向只为portrait. - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation { return UIInterfaceOrientationPortrait == toInterfaceOrientation; } - (BOOL)shouldAutorotate { return YES; } - (NSUInteger)supportedInterfaceOrientations { return UIInterfaceOrientationMaskPortrait; } ","link":"https://blog.xioayee.top/post/heng-ping-shu-ping-zi-gua-ying-zong-jie/"},{"title":"自定义UITextField背景","content":"设置背景图片 UIImage *textFieldBgImage = [[UIImage imageNamed:@&quot;textfield_bg.png&quot;] stretchableImageWithLeftCapWidth:5 topCapHeight:5]; [self.textField setBackground:textFieldBgImage]; 修改文字边距 设置好图片后输入文字会发现左边的文字和背景图片的边框重叠了，需要设置一下文本框的边距，可是UITextField没有相应的属性可以设置，所以只有重写UITextField的相关方法。 @implementation UITextField(UITextFieldCategory) - (CGRect)textRectForBounds:(CGRect)bounds { CGRect inset = CGRectInset(bounds, 5, 5); return inset; } - (CGRect)editingRectForBounds:(CGRect)bounds { CGRect inset = CGRectInset(bounds, 5, 5); return inset; } @end 上面偷了个懒，直接用category的方式重写了这个两个方法。 ","link":"https://blog.xioayee.top/post/zi-ding-yi-uitextfield-bei-jing/"},{"title":".net的DateTime时间格式转成NSDate","content":"最近项目中用到的接口是.net写的，传过来的日期格式是 2013-04-10T10:36:48.787359+08:00 , 这么一大串想解析成NSDate格式还真不是一件容易的事，幸好已经有人把转换类写出来了。 转换类 老外写的转换类，地址不记得了，直接上代码 /*ISO8601DateFormatter.h * *Created by Peter Hosey on 2009-04-11. *Copyright 2009 Peter Hosey. All rights reserved. */ #import &lt;Foundation/Foundation.h&gt; /*This class converts dates to and from ISO 8601 strings. A good introduction to ISO 8601: &lt;http://www.cl.cam.ac.uk/~mgk25/iso-time.html&gt; * *Parsing can be done strictly, or not. When you parse loosely, leading whitespace is ignored, as is anything after the date. *The loose parser will return an NSDate for this string: @&quot; \\t\\r\\n\\f\\t 2006-03-02!!!&quot; *Leading non-whitespace will not be ignored; the string will be rejected, and nil returned. See the README that came with this addition. * *The strict parser will only accept a string if the date is the entire string. The above string would be rejected immediately, solely on these grounds. *Also, the loose parser provides some extensions that the strict parser doesn't. *For example, the standard says for &quot;-DDD&quot; (an ordinal date in the implied year) that the logical representation (meaning, hierarchically) would be &quot;--DDD&quot;, but because that extra hyphen is &quot;superfluous&quot;, it was omitted. *The loose parser will accept the extra hyphen; the strict parser will not. *A full list of these extensions is in the README file. */ /*The format to either expect or produce. *Calendar format is YYYY-MM-DD. *Ordinal format is YYYY-DDD, where DDD ranges from 1 to 366; for example, 2009-32 is 2009-02-01. *Week format is YYYY-Www-D, where ww ranges from 1 to 53 (the 'W' is literal) and D ranges from 1 to 7; for example, 2009-W05-07. */ enum { ISO8601DateFormatCalendar, ISO8601DateFormatOrdinal, ISO8601DateFormatWeek, }; typedef NSUInteger ISO8601DateFormat; //The default separator for time values. Currently, this is ':'. extern unichar ISO8601DefaultTimeSeparatorCharacter; @interface ISO8601DateFormatter: NSFormatter { NSString *lastUsedFormatString; NSDateFormatter *unparsingFormatter; NSCalendar *parsingCalendar, *unparsingCalendar; NSTimeZone *defaultTimeZone; ISO8601DateFormat format; unichar timeSeparator; BOOL includeTime; BOOL parsesStrictly; } //Call this if you get a memory warning. + (void) purgeGlobalCaches; @property(nonatomic, retain) NSTimeZone *defaultTimeZone; #pragma mark Parsing //As a formatter, this object converts strings to dates. @property BOOL parsesStrictly; - (NSDateComponents *) dateComponentsFromString:(NSString *)string; - (NSDateComponents *) dateComponentsFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone; - (NSDateComponents *) dateComponentsFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone range:(out NSRange *)outRange; - (NSDate *) dateFromString:(NSString *)string; - (NSDate *) dateFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone; - (NSDate *) dateFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone range:(out NSRange *)outRange; #pragma mark Unparsing @property ISO8601DateFormat format; @property BOOL includeTime; @property unichar timeSeparator; - (NSString *) stringFromDate:(NSDate *)date; - (NSString *) stringFromDate:(NSDate *)date timeZone:(NSTimeZone *)timeZone; @end /*ISO8601DateFormatter.m * *Created by Peter Hosey on 2009-04-11. *Copyright 2009 Peter Hosey. All rights reserved. */ #import &lt;Foundation/Foundation.h&gt; #import &quot;ISO8601DateFormatter.h&quot; #ifndef DEFAULT_TIME_SEPARATOR # define DEFAULT_TIME_SEPARATOR ':' #endif unichar ISO8601DefaultTimeSeparatorCharacter = DEFAULT_TIME_SEPARATOR; //Unicode date formats. #define ISO_CALENDAR_DATE_FORMAT @&quot;yyyy-MM-dd&quot; //#define ISO_WEEK_DATE_FORMAT @&quot;YYYY-'W'ww-ee&quot; //Doesn't actually work because NSDateComponents counts the weekday starting at 1. #define ISO_ORDINAL_DATE_FORMAT @&quot;yyyy-DDD&quot; #define ISO_TIME_FORMAT @&quot;HH:mm:ss&quot; #define ISO_TIME_WITH_TIMEZONE_FORMAT ISO_TIME_FORMAT @&quot;Z&quot; //printf formats. #define ISO_TIMEZONE_UTC_FORMAT @&quot;Z&quot; #define ISO_TIMEZONE_OFFSET_FORMAT @&quot;%+.2d%.2d&quot; @interface ISO8601DateFormatter(UnparsingPrivate) - (NSString *) replaceColonsInString:(NSString *)timeFormat withTimeSeparator:(unichar)timeSep; - (NSString *) stringFromDate:(NSDate *)date formatString:(NSString *)dateFormat timeZone:(NSTimeZone *)timeZone; - (NSString *) weekDateStringForDate:(NSDate *)date timeZone:(NSTimeZone *)timeZone; @end static NSMutableDictionary *timeZonesByOffset; @implementation ISO8601DateFormatter + (void) initialize { if (!timeZonesByOffset) { timeZonesByOffset = [[NSMutableDictionary alloc] init]; } } + (void) purgeGlobalCaches { NSMutableDictionary *oldCache = timeZonesByOffset; timeZonesByOffset = nil; [oldCache release]; } - (NSCalendar *) makeCalendarWithDesiredConfiguration { NSCalendar *calendar = [[[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar] autorelease]; calendar.firstWeekday = 2; //Monday calendar.timeZone = [NSTimeZone defaultTimeZone]; return calendar; } - (id) init { if ((self = [super init])) { parsingCalendar = [[self makeCalendarWithDesiredConfiguration] retain]; unparsingCalendar = [[self makeCalendarWithDesiredConfiguration] retain]; format = ISO8601DateFormatCalendar; timeSeparator = ISO8601DefaultTimeSeparatorCharacter; includeTime = NO; parsesStrictly = NO; } return self; } - (void) dealloc { [defaultTimeZone release]; [unparsingFormatter release]; [lastUsedFormatString release]; [parsingCalendar release]; [unparsingCalendar release]; [super dealloc]; } @synthesize defaultTimeZone; - (void) setDefaultTimeZone:(NSTimeZone *)tz { if (defaultTimeZone != tz) { [defaultTimeZone release]; defaultTimeZone = [tz retain]; unparsingCalendar.timeZone = defaultTimeZone; } } //The following properties are only here because GCC doesn't like @synthesize in category implementations. #pragma mark Parsing @synthesize parsesStrictly; static NSUInteger read_segment(const unsigned char *str, const unsigned char **next, NSUInteger *out_num_digits); static NSUInteger read_segment_4digits(const unsigned char *str, const unsigned char **next, NSUInteger *out_num_digits); static NSUInteger read_segment_2digits(const unsigned char *str, const unsigned char **next); static double read_double(const unsigned char *str, const unsigned char **next); static BOOL is_leap_year(NSUInteger year); /*Valid ISO 8601 date formats: * *YYYYMMDD *YYYY-MM-DD *YYYY-MM *YYYY *YY //century * //Implied century: YY is 00-99 * YYMMDD * YY-MM-DD * -YYMM * -YY-MM * -YY * //Implied year * --MMDD * --MM-DD * --MM * //Implied year and month * ---DD * //Ordinal dates: DDD is the number of the day in the year (1-366) *YYYYDDD *YYYY-DDD * YYDDD * YY-DDD * -DDD * //Week-based dates: ww is the number of the week, and d is the number (1-7) of the day in the week *yyyyWwwd *yyyy-Www-d *yyyyWww *yyyy-Www *yyWwwd *yy-Www-d *yyWww *yy-Www * //Year of the implied decade *-yWwwd *-y-Www-d *-yWww *-y-Www * //Week and day of implied year * -Wwwd * -Www-d * //Week only of implied year * -Www * //Day only of implied week * -W-d */ - (NSDateComponents *) dateComponentsFromString:(NSString *)string { return [self dateComponentsFromString:string timeZone:NULL]; } - (NSDateComponents *) dateComponentsFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone { return [self dateComponentsFromString:string timeZone:outTimeZone range:NULL]; } - (NSDateComponents *) dateComponentsFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone range:(out NSRange *)outRange { NSDate *now = [NSDate date]; NSDateComponents *components = [[[NSDateComponents alloc] init] autorelease]; NSDateComponents *nowComponents = [parsingCalendar components:(NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit) fromDate:now]; NSUInteger //Date year, month_or_week = 0U, day = 0U, //Time hour = 0U; NSTimeInterval minute = 0.0, second = 0.0; //Time zone NSInteger tz_hour = 0; NSInteger tz_minute = 0; enum { monthAndDate, week, dateOnly } dateSpecification = monthAndDate; BOOL strict = self.parsesStrictly; unichar timeSep = self.timeSeparator; if (strict) timeSep = ISO8601DefaultTimeSeparatorCharacter; NSAssert(timeSep != '\\0', @&quot;Time separator must not be NUL.&quot;); BOOL isValidDate = ([string length] &gt; 0U); NSTimeZone *timeZone = nil; const unsigned char *ch = (const unsigned char *)[string UTF8String]; NSRange range = { 0U, 0U }; const unsigned char *start_of_date = NULL; if (strict &amp;&amp; isspace(*ch)) { range.location = NSNotFound; isValidDate = NO; } else { //Skip leading whitespace. NSUInteger i = 0U; for(NSUInteger len = strlen((const char *)ch); i &lt; len; ++i) { if (!isspace(ch[i])) break; } range.location = i; ch += i; start_of_date = ch; NSUInteger segment; NSUInteger num_leading_hyphens = 0U, num_digits = 0U; if (*ch == 'T') { //There is no date here, only a time. Set the date to now; then we'll parse the time. isValidDate = isdigit(*++ch); year = nowComponents.year; month_or_week = nowComponents.month; day = nowComponents.day; } else { while(*ch == '-') { ++num_leading_hyphens; ++ch; } segment = read_segment(ch, &amp;ch, &amp;num_digits); switch(num_digits) { case 0: if (*ch == 'W') { if ((ch[1] == '-') &amp;&amp; isdigit(ch[2]) &amp;&amp; ((num_leading_hyphens == 1U) || ((num_leading_hyphens == 2U) &amp;&amp; !strict))) { year = nowComponents.year; month_or_week = 1U; ch += 2; goto parseDayAfterWeek; } else if (num_leading_hyphens == 1U) { year = nowComponents.year; goto parseWeekAndDay; } else isValidDate = NO; } else isValidDate = NO; break; case 8: //YYYY MM DD if (num_leading_hyphens &gt; 0U) isValidDate = NO; else { day = segment % 100U; segment /= 100U; month_or_week = segment % 100U; year = segment / 100U; } break; case 6: //YYMMDD (implicit century) if (num_leading_hyphens &gt; 0U) isValidDate = NO; else { day = segment % 100U; segment /= 100U; month_or_week = segment % 100U; year = nowComponents.year; year -= (year % 100U); year += segment / 100U; } break; case 4: switch(num_leading_hyphens) { case 0: //YYYY year = segment; if (*ch == '-') ++ch; if (!isdigit(*ch)) { if (*ch == 'W') goto parseWeekAndDay; else month_or_week = day = 1U; } else { segment = read_segment(ch, &amp;ch, &amp;num_digits); switch(num_digits) { case 4: //MMDD day = segment % 100U; month_or_week = segment / 100U; break; case 2: //MM month_or_week = segment; if (*ch == '-') ++ch; if (!isdigit(*ch)) day = 1U; else day = read_segment(ch, &amp;ch, NULL); break; case 3: //DDD day = segment % 1000U; dateSpecification = dateOnly; if (strict &amp;&amp; (day &gt; (365U + is_leap_year(year)))) isValidDate = NO; break; default: isValidDate = NO; } } break; case 1: //YYMM month_or_week = segment % 100U; year = segment / 100U; if (*ch == '-') ++ch; if (!isdigit(*ch)) day = 1U; else day = read_segment(ch, &amp;ch, NULL); break; case 2: //MMDD day = segment % 100U; month_or_week = segment / 100U; year = nowComponents.year; break; default: isValidDate = NO; } //switch(num_leading_hyphens) (4 digits) break; case 1: if (strict) { //Two digits only - never just one. if (num_leading_hyphens == 1U) { if (*ch == '-') ++ch; if (*++ch == 'W') { year = nowComponents.year; year -= (year % 10U); year += segment; goto parseWeekAndDay; } else isValidDate = NO; } else isValidDate = NO; break; } case 2: switch(num_leading_hyphens) { case 0: if (*ch == '-') { //Implicit century year = nowComponents.year; year -= (year % 100U); year += segment; if (*++ch == 'W') goto parseWeekAndDay; else if (!isdigit(*ch)) { goto centuryOnly; } else { //Get month and/or date. segment = read_segment_4digits(ch, &amp;ch, &amp;num_digits); NSLog(@&quot;(%@) parsing month; segment is %lu and ch is %s&quot;, string, (unsigned long)segment, ch); switch(num_digits) { case 4: //YY-MMDD day = segment % 100U; month_or_week = segment / 100U; break; case 1: //YY-M; YY-M-DD (extension) if (strict) { isValidDate = NO; break; } case 2: //YY-MM; YY-MM-DD month_or_week = segment; if (*ch == '-') { if (isdigit(*++ch)) day = read_segment_2digits(ch, &amp;ch); else day = 1U; } else day = 1U; break; case 3: //Ordinal date. day = segment; dateSpecification = dateOnly; break; } } } else if (*ch == 'W') { year = nowComponents.year; year -= (year % 100U); year += segment; parseWeekAndDay: //*ch should be 'W' here. if (!isdigit(*++ch)) { //Not really a week-based date; just a year followed by '-W'. if (strict) isValidDate = NO; else month_or_week = day = 1U; } else { month_or_week = read_segment_2digits(ch, &amp;ch); if (*ch == '-') ++ch; parseDayAfterWeek: day = isdigit(*ch) ? read_segment_2digits(ch, &amp;ch) : 1U; dateSpecification = week; } } else { //Century only. Assume current year. centuryOnly: year = segment * 100U + nowComponents.year % 100U; month_or_week = day = 1U; } break; case 1:; //-YY; -YY-MM (implicit century) NSLog(@&quot;(%@) found %lu digits and one hyphen, so this is either -YY or -YY-MM; segment (year) is %lu&quot;, string, (unsigned long)num_digits, (unsigned long)segment); NSUInteger current_year = nowComponents.year; NSUInteger current_century = (current_year % 100U); year = segment + (current_year - current_century); if (num_digits == 1U) //implied decade year += current_century - (current_year % 10U); if (*ch == '-') { ++ch; month_or_week = read_segment_2digits(ch, &amp;ch); NSLog(@&quot;(%@) month is %lu&quot;, string, (unsigned long)month_or_week); } day = 1U; break; case 2: //--MM; --MM-DD year = nowComponents.year; month_or_week = segment; if (*ch == '-') { ++ch; day = read_segment_2digits(ch, &amp;ch); } break; case 3: //---DD year = nowComponents.year; month_or_week = nowComponents.month; day = segment; break; default: isValidDate = NO; } //switch(num_leading_hyphens) (2 digits) break; case 7: //YYYY DDD (ordinal date) if (num_leading_hyphens &gt; 0U) isValidDate = NO; else { day = segment % 1000U; year = segment / 1000U; dateSpecification = dateOnly; if (strict &amp;&amp; (day &gt; (365U + is_leap_year(year)))) isValidDate = NO; } break; case 3: //--DDD (ordinal date, implicit year) //Technically, the standard only allows one hyphen. But it says that two hyphens is the logical implementation, and one was dropped for brevity. So I have chosen to allow the missing hyphen. if ((num_leading_hyphens &lt; 1U) || ((num_leading_hyphens &gt; 2U) &amp;&amp; !strict)) isValidDate = NO; else { day = segment; year = nowComponents.year; dateSpecification = dateOnly; if (strict &amp;&amp; (day &gt; (365U + is_leap_year(year)))) isValidDate = NO; } break; default: isValidDate = NO; } } if (isValidDate) { if (isspace(*ch) || (*ch == 'T')) ++ch; if (isdigit(*ch)) { hour = read_segment_2digits(ch, &amp;ch); if (*ch == timeSep) { ++ch; if ((timeSep == ',') || (timeSep == '.')) { //We can't do fractional minutes when '.' is the segment separator. //Only allow whole minutes and whole seconds. minute = read_segment_2digits(ch, &amp;ch); if (*ch == timeSep) { ++ch; second = read_segment_2digits(ch, &amp;ch); } } else { //Allow a fractional minute. //If we don't get a fraction, look for a seconds segment. //Otherwise, the fraction of a minute is the seconds. minute = read_double(ch, &amp;ch); second = modf(minute, &amp;minute); if (second &gt; DBL_EPSILON) second *= 60.0; //Convert fraction (e.g. .5) into seconds (e.g. 30). else if (*ch == timeSep) { ++ch; second = read_double(ch, &amp;ch); } } } if (!strict) { if (isspace(*ch)) ++ch; } switch(*ch) { case 'Z': timeZone = [NSTimeZone timeZoneWithAbbreviation:@&quot;UTC&quot;]; break; case '+': case '-':; BOOL negative = (*ch == '-'); if (isdigit(*++ch)) { //Read hour offset. segment = *ch - '0'; if (isdigit(*++ch)) { segment *= 10U; segment += *(ch++) - '0'; } tz_hour = (NSInteger)segment; if (negative) tz_hour = -tz_hour; //Optional separator. if (*ch == timeSep) ++ch; if (isdigit(*ch)) { //Read minute offset. segment = *ch - '0'; if (isdigit(*++ch)) { segment *= 10U; segment += *ch - '0'; } tz_minute = segment; if (negative) tz_minute = -tz_minute; } NSInteger timeZoneOffset = (tz_hour * 3600) + (tz_minute * 60); NSNumber *offsetNum = [NSNumber numberWithInteger:timeZoneOffset]; timeZone = [timeZonesByOffset objectForKey:offsetNum]; if (!timeZone) { timeZone = [NSTimeZone timeZoneForSecondsFromGMT:timeZoneOffset]; if (timeZone) [timeZonesByOffset setObject:timeZone forKey:offsetNum]; } } } } } if (isValidDate) { components.year = year; components.day = day; components.hour = hour; components.minute = (NSInteger)minute; components.second = (NSInteger)second; switch(dateSpecification) { case monthAndDate: components.month = month_or_week; break; case week:; //Adapted from &lt;http://personal.ecu.edu/mccartyr/ISOwdALG.txt&gt;. //This works by converting the week date into an ordinal date, then letting the next case handle it. NSUInteger prevYear = year - 1U; NSUInteger YY = prevYear % 100U; NSUInteger C = prevYear - YY; NSUInteger G = YY + YY / 4U; NSUInteger isLeapYear = (((C / 100U) % 4U) * 5U); NSUInteger Jan1Weekday = (isLeapYear + G) % 7U; enum { monday, tuesday, wednesday, thursday/*, friday, saturday, sunday*/ }; components.day = ((8U - Jan1Weekday) + (7U * (Jan1Weekday &gt; thursday))) + (day - 1U) + (7U * (month_or_week - 2)); case dateOnly: //An &quot;ordinal date&quot;. break; } } } //if (!(strict &amp;&amp; isdigit(ch[0]))) if (outRange) { if (isValidDate) range.length = ch - start_of_date; else range.location = NSNotFound; *outRange = range; } if (outTimeZone) { *outTimeZone = timeZone; } return components; } - (NSDate *) dateFromString:(NSString *)string { return [self dateFromString:string timeZone:NULL]; } - (NSDate *) dateFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone { return [self dateFromString:string timeZone:outTimeZone range:NULL]; } - (NSDate *) dateFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone range:(out NSRange *)outRange { NSTimeZone *timeZone = nil; NSDateComponents *components = [self dateComponentsFromString:string timeZone:&amp;timeZone range:outRange]; if (outTimeZone) *outTimeZone = timeZone; parsingCalendar.timeZone = timeZone; return [parsingCalendar dateFromComponents:components]; } - (BOOL)getObjectValue:(id *)outValue forString:(NSString *)string errorDescription:(NSString **)error { NSDate *date = [self dateFromString:string]; if (outValue) *outValue = date; return (date != nil); } #pragma mark Unparsing @synthesize format; @synthesize includeTime; @synthesize timeSeparator; - (NSString *) replaceColonsInString:(NSString *)timeFormat withTimeSeparator:(unichar)timeSep { if (timeSep != ':') { NSMutableString *timeFormatMutable = [[timeFormat mutableCopy] autorelease]; [timeFormatMutable replaceOccurrencesOfString:@&quot;:&quot; withString:[NSString stringWithCharacters:&amp;timeSep length:1U] options:NSBackwardsSearch | NSLiteralSearch range:(NSRange){ 0UL, [timeFormat length] }]; timeFormat = timeFormatMutable; } return timeFormat; } - (NSString *) stringFromDate:(NSDate *)date { NSTimeZone *timeZone = self.defaultTimeZone; if (!timeZone) timeZone = [NSTimeZone defaultTimeZone]; return [self stringFromDate:date timeZone:timeZone]; } - (NSString *) stringFromDate:(NSDate *)date timeZone:(NSTimeZone *)timeZone { switch (self.format) { case ISO8601DateFormatCalendar: return [self stringFromDate:date formatString:ISO_CALENDAR_DATE_FORMAT timeZone:timeZone]; case ISO8601DateFormatWeek: return [self weekDateStringForDate:date timeZone:timeZone]; case ISO8601DateFormatOrdinal: return [self stringFromDate:date formatString:ISO_ORDINAL_DATE_FORMAT timeZone:timeZone]; default: [NSException raise:NSInternalInconsistencyException format:@&quot;self.format was %d, not calendar (%d), week (%d), or ordinal (%d)&quot;, self.format, ISO8601DateFormatCalendar, ISO8601DateFormatWeek, ISO8601DateFormatOrdinal]; return nil; } } - (NSString *) stringFromDate:(NSDate *)date formatString:(NSString *)dateFormat timeZone:(NSTimeZone *)timeZone { if (includeTime) dateFormat = [dateFormat stringByAppendingFormat:@&quot;'T'%@&quot;, [self replaceColonsInString:ISO_TIME_FORMAT withTimeSeparator:self.timeSeparator]]; unparsingCalendar.timeZone = timeZone; if (dateFormat != lastUsedFormatString) { [unparsingFormatter release]; unparsingFormatter = nil; [lastUsedFormatString release]; lastUsedFormatString = [dateFormat retain]; } if (!unparsingFormatter) { unparsingFormatter = [[NSDateFormatter alloc] init]; unparsingFormatter.formatterBehavior = NSDateFormatterBehavior10_4; unparsingFormatter.dateFormat = dateFormat; unparsingFormatter.calendar = unparsingCalendar; } NSString *str = [unparsingFormatter stringForObjectValue:date]; if (includeTime) { NSInteger offset = [timeZone secondsFromGMT]; offset /= 60; //bring down to minutes if (offset == 0) str = [str stringByAppendingString:ISO_TIMEZONE_UTC_FORMAT]; else str = [str stringByAppendingFormat:ISO_TIMEZONE_OFFSET_FORMAT, offset / 60, offset % 60]; } //Undo the change we made earlier unparsingCalendar.timeZone = self.defaultTimeZone; return str; } - (NSString *) stringForObjectValue:(id)value { NSParameterAssert([value isKindOfClass:[NSDate class]]); return [self stringFromDate:(NSDate *)value]; } /*Adapted from: * Algorithm for Converting Gregorian Dates to ISO 8601 Week Date * Rick McCarty, 1999 * http://personal.ecu.edu/mccartyr/ISOwdALG.txt */ - (NSString *) weekDateStringForDate:(NSDate *)date timeZone:(NSTimeZone *)timeZone { unparsingCalendar.timeZone = timeZone; NSDateComponents *components = [unparsingCalendar components:NSYearCalendarUnit | NSWeekdayCalendarUnit | NSDayCalendarUnit fromDate:date]; //Determine the ordinal date. NSDateComponents *startOfYearComponents = [unparsingCalendar components:NSYearCalendarUnit fromDate:date]; startOfYearComponents.month = 1; startOfYearComponents.day = 1; NSDateComponents *ordinalComponents = [unparsingCalendar components:NSDayCalendarUnit fromDate:[unparsingCalendar dateFromComponents:startOfYearComponents] toDate:date options:0]; ordinalComponents.day += 1; enum { monday, tuesday, wednesday, thursday, friday, saturday, sunday }; enum { january = 1, february, march, april, may, june, july, august, september, october, november, december }; NSInteger year = components.year; NSInteger week = 0; //The old unparser added 6 to [calendarDate dayOfWeek], which was zero-based; components.weekday is one-based, so we now add only 5. NSInteger dayOfWeek = (components.weekday + 5) % 7; NSInteger dayOfYear = ordinalComponents.day; NSInteger prevYear = year - 1; BOOL yearIsLeapYear = is_leap_year(year); BOOL prevYearIsLeapYear = is_leap_year(prevYear); NSInteger YY = prevYear % 100; NSInteger C = prevYear - YY; NSInteger G = YY + YY / 4; NSInteger Jan1Weekday = (((((C / 100) % 4) * 5) + G) % 7); NSInteger weekday = ((dayOfYear + Jan1Weekday) - 1) % 7; if((dayOfYear &lt;= (7 - Jan1Weekday)) &amp;&amp; (Jan1Weekday &gt; thursday)) { week = 52 + ((Jan1Weekday == friday) || ((Jan1Weekday == saturday) &amp;&amp; prevYearIsLeapYear)); --year; } else { NSInteger lengthOfYear = 365 + yearIsLeapYear; if((lengthOfYear - dayOfYear) &lt; (thursday - weekday)) { ++year; week = 1; } else { NSInteger J = dayOfYear + (sunday - weekday) + Jan1Weekday; week = J / 7 - (Jan1Weekday &gt; thursday); } } NSString *timeString; if(includeTime) { NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; unichar timeSep = self.timeSeparator; if (!timeSep) timeSep = ISO8601DefaultTimeSeparatorCharacter; formatter.dateFormat = [self replaceColonsInString:ISO_TIME_WITH_TIMEZONE_FORMAT withTimeSeparator:timeSep]; timeString = [formatter stringForObjectValue:date]; [formatter release]; } else timeString = @&quot;&quot;; return [NSString stringWithFormat:@&quot;%lu-W%02lu-%02lu%@&quot;, (unsigned long)year, (unsigned long)week, ((unsigned long)dayOfWeek) + 1U, timeString]; } @end static NSUInteger read_segment(const unsigned char *str, const unsigned char **next, NSUInteger *out_num_digits) { NSUInteger num_digits = 0U; NSUInteger value = 0U; while(isdigit(*str)) { value *= 10U; value += *str - '0'; ++num_digits; ++str; } if (next) *next = str; if (out_num_digits) *out_num_digits = num_digits; return value; } static NSUInteger read_segment_4digits(const unsigned char *str, const unsigned char **next, NSUInteger *out_num_digits) { NSUInteger num_digits = 0U; NSUInteger value = 0U; if (isdigit(*str)) { value += *(str++) - '0'; ++num_digits; } if (isdigit(*str)) { value *= 10U; value += *(str++) - '0'; ++num_digits; } if (isdigit(*str)) { value *= 10U; value += *(str++) - '0'; ++num_digits; } if (isdigit(*str)) { value *= 10U; value += *(str++) - '0'; ++num_digits; } if (next) *next = str; if (out_num_digits) *out_num_digits = num_digits; return value; } static NSUInteger read_segment_2digits(const unsigned char *str, const unsigned char **next) { NSUInteger value = 0U; if (isdigit(*str)) value += *str - '0'; if (isdigit(*++str)) { value *= 10U; value += *(str++) - '0'; } if (next) *next = str; return value; } //strtod doesn't support ',' as a separator. This does. static double read_double(const unsigned char *str, const unsigned char **next) { double value = 0.0; if (str) { NSUInteger int_value = 0; while(isdigit(*str)) { int_value *= 10U; int_value += (*(str++) - '0'); } value = int_value; if (((*str == ',') || (*str == '.'))) { ++str; register double multiplier, multiplier_multiplier; multiplier = multiplier_multiplier = 0.1; while(isdigit(*str)) { value += (*(str++) - '0') * multiplier; multiplier *= multiplier_multiplier; } } } if (next) *next = str; return value; } static BOOL is_leap_year(NSUInteger year) { return \\ ((year % 4U) == 0U) &amp;&amp; (((year % 100U) != 0U) || ((year % 400U) == 0U)); } 用法 ISO8601DateFormatter *dateFormat = [[[ISO8601DateFormatter alloc] init] autorelease]; NSDate *serverTime = [dateFormat dateFromString:dateTime]; ","link":"https://blog.xioayee.top/post/net-de-datetime-shi-jian-ge-shi-zhuan-cheng-nsdate/"},{"title":"使用Sencha Touch 2.1进行iOS开发 —— 项目文件结构及代码分析","content":"从第一篇文章我们知道了如何通过sencha命令创建Sencha Touch项目，而创建的项目里面已经包含了不少文件，如要开始写代码，我们有必要先了解所创建项目的文件结构及代码。 文件结构 在终端输入 $ sencha generate app HelloWorld ~/Desktop/HelloWorld 我们创建了一个名为HelloWorld的项目，进入该文件夹可以看到文件如下： app/ controller/ model/ profile/ store/ view/ Main.js app.js app.json build.xml index.html packager.json resources/ touch/ packager.json 一些sencha package命令要用到的文件，里面是一些编译打包配置信息。 app.js 包含了应用的初始化逻辑代码。 app.json 应用部署的配置。 app/ MVC结构的应用源代码文件。 resources/ 资源文件夹。 touch/ Sencha Touch SDK文件。 代码分析 应用入口 app.js是应用的初始化文件，也就是意味着应用的入口在这里，打开该文件，我可以看到这一段代码： launch: function() { // Destroy the #appLoadingIndicator element Ext.fly('appLoadingIndicator').destroy(); // Initialize the main view Ext.Viewport.add(Ext.create('HelloWorld.view.Main')); }, Ext.create('HelloWorld.view.Main')创建了一个HelloWorld.view.Main实例并加入到Viewport中，也就是说我们进入应用看到的主界面的代码源文件是app/view/Main.js文件。 xtype 打开Main.js文件，上一篇文章已经讲过类的定义了，所以HelloWorld.view.Main类的定义应该比较好理解。需要注意的是里面的xtype: 'main'属性，这个是定义当前类的xtype，方便被其他类用进行引用，而config下items的xtype则是对其他已定义xtype的类的引用。 下面是SDK所有的xtype及其对应的类： xtype Class ----------------- --------------------- actionsheet Ext.ActionSheet audio Ext.Audio button Ext.Button component Ext.Component container Ext.Container image Ext.Img label Ext.Label loadmask Ext.LoadMask map Ext.Map mask Ext.Mask media Ext.Media panel Ext.Panel segmentedbutton Ext.SegmentedButton sheet Ext.Sheet spacer Ext.Spacer title Ext.Title titlebar Ext.TitleBar toolbar Ext.Toolbar video Ext.Video carousel Ext.carousel.Carousel carouselindicator Ext.carousel.Indicator navigationview Ext.navigation.View datepicker Ext.picker.Date picker Ext.picker.Picker pickerslot Ext.picker.Slot slider Ext.slider.Slider thumb Ext.slider.Thumb tabbar Ext.tab.Bar tabpanel Ext.tab.Panel tab Ext.tab.Tab viewport Ext.viewport.Default DataView Components --------------------------------------------- dataview Ext.dataview.DataView list Ext.dataview.List listitemheader Ext.dataview.ListItemHeader nestedlist Ext.dataview.NestedList dataitem Ext.dataview.component.DataItem Form Components --------------------------------------------- checkboxfield Ext.field.Checkbox datepickerfield Ext.field.DatePicker emailfield Ext.field.Email field Ext.field.Field hiddenfield Ext.field.Hidden input Ext.field.Input numberfield Ext.field.Number passwordfield Ext.field.Password radiofield Ext.field.Radio searchfield Ext.field.Search selectfield Ext.field.Select sliderfield Ext.field.Slider spinnerfield Ext.field.Spinner textfield Ext.field.Text textareafield Ext.field.TextArea textareainput Ext.field.TextAreaInput togglefield Ext.field.Toggle urlfield Ext.field.Url fieldset Ext.form.FieldSet formpanel Ext.form.Panel ","link":"https://blog.xioayee.top/post/shi-yong-sencha-touch-21-jin-xing-ios-kai-fa-xiang-mu-wen-jian-jie-gou-ji-dai-ma-fen-xi2/"},{"title":"Shecha Touch实例学习","content":"通过前几篇文章的介绍，大家应该对Sencha Touch总体有了了解，现在已经可以开始做一些简单的应用。这一次我们要做的是一个简单通讯录应用。 原型图 开始工作之前我们先把思路整理一下，最好能先把原型图画一下。 开始编码 创建名为AddressBook的Sencha Touch项目。 把准备好联系人数据文件contacts.json拷贝到项目根目录下。 修改app.json配置文件。 缓存： &quot;appCache&quot;: { /** * List of items in the CACHE MANIFEST section */ &quot;cache&quot;: [ &quot;index.html&quot;, &quot;contacts.json&quot; //加入新增的数据文件 ], 资源： /** * Extra resources to be copied along when build */ &quot;resources&quot;: [ &quot;contacts.json&quot;, //加入新增的数据文件 &quot;resources/images&quot;, &quot;resources/icons&quot;, &quot;resources/startup&quot; ], 修改app/view/Main.js文件 Ext.define('AddressBook.view.Main', { extend: 'Ext.navigation.View', xtype: 'mainview', //自定义xtype config: { scrollable: 'vertical', items: [ { xtype: 'list', title: 'Contacts', //设置navigationView的title id: 'contact-list', itemTpl: [ '&lt;div&gt;&lt;img src=\\'\\' /&gt; {firstName}&amp;nbsp;{lastName}&lt;/div&gt;' //自定义list cell的模版 ], store: 'contacts', //指定数据仓库 grouped: true, indexBar: true } ] } }); 由于我们需要点击该列表进入对应的联系人详情页，所以应该选择navigation控件，把Main类的父类设为navigation.View:extend: 'Ext.navigation.View'。 ###新建app/store/contacts.js和app/model/ContactModel.js文件 contacts.js： Ext.define('AddressBook.store.contacts', { extend: 'Ext.data.Store', requires: [ 'AddressBook.model.ContactModel' ], config: { autoLoad: true, model: 'AddressBook.model.ContactModel', remoteSort: false, storeId: 'contacts', proxy: { type: 'ajax', url: 'contacts.json' }, sorters: 'firstName', grouper: { groupFn: function(record) { return record.get('lastName')[0]; } } } }); ContactModel.js： Ext.define('AddressBook.model.ContactModel', { extend: 'Ext.data.Model', config: { fields: [ 'firstName', 'lastName', 'title' ] } }); ","link":"https://blog.xioayee.top/post/shecha-touch-shi-li-xue-xi/"},{"title":"使用Sencha Touch 2.1进行iOS开发 —— 类的定义与使用","content":"类的定义 Sencha Touch有自己的类定义方式，我们先来看个例子： Ext.define('Animal', { config: { name: null }, constructor: function(config) { this.initConfig(config); }, speak: function() { alert('grunt'); } }); 上面我们简单地定义了一个Animal类，只有一个name属性和一个方法speak(); 类的继承 Ext.define('Human', { extend: 'Animal', speak: function() { alert(this.getName()); } }); 我们定义了一个Human类继承自Animal，并重写speak()方法。 类的实例化 var bob = Ext.create('Human', { name: 'Bob' }); bob.speak(); //alerts 'Bob' 通过Ext.create()静态方法创建类实例。 getter和setter方法 对应的属性会自动生成getter和setter方法，如上面继承的例子中的this.getName()，setter方法为：this.setName('')。 Ext.define('Human', { extend: 'Animal', applyName: function(newName, oldName) { return confirm('Are you sure you want to change name to ' + newName + '?')? newName : oldName; } }); applyName()方法是在调用setter方法后自动回调的方法，上面例子将在调用setter方法后弹出确认窗口询问是否修改name的值，点击no的话则不进行修改。 Ext.define('Human', { extend: 'Animal', updateName: function(newName, oldName) { alert('Name changed. New name is: ' + newName); } }); updateName()方法则是在调用setter方法后并且改属性值已经修改了的情况下自动回调的。 依赖和动态加载 有时候我们需要在类里面使用某个类的，这时候我们需要加入这个类的引用声明：requires: 'Ext.MessageBox'。 Ext.define('Human', { extend: 'Animal', requires: 'Ext.MessageBox', speak: function() { Ext.Msg.alert(this.getName(), &quot;Speaks...&quot;); } }); 加入引用声明后，Sencha Touch会自动判断是否Ext.MessageBox已经加载，如果未加载的话则会自动通过AJAX加载对应的类文件。 命名空间 以上一篇文章的Main.js文件为例 Ext.define('HelloSenCha.view.Main', { extend: 'Ext.navigation.View', xtype: 'mainview', requires: [ 'HelloSenCha.view.Contacts', 'HelloSenCha.view.contact.Show', 'HelloSenCha.view.contact.Edit' ], ... 类名规则为：项目名称.目录1.目录2...类名，也就是说，Main.js和Contacts.js文件在view文件夹下，Show.js和Edit.js在view/contact文件夹下。 ","link":"https://blog.xioayee.top/post/shi-yong-sencha-touch-21-jin-xing-ios-kai-fa-lei-de-ding-yi-yu-shi-yong/"},{"title":"使用Sencha Touch 2.1进行iOS开发 —— 开发环境搭建","content":"最近由于要用到Sencha Touch 2.1进行项目的开发，于是开始了对Sencha Touch的学习，学习Sencha Touch第一步当然是搭建开发环境。 开发环境搭建 Sencha iOS开发基本环境 Mac OSX Xcode Sencha Touch SDK Sencha Touch SDK下载 开发环境搭建的第一步当然就是下载SDK，Sencha Touch 2.1的SDK可以到官网下载：下载页面, 这里需要填个邮箱地址，随便填一个地址就可以了，会自动跳转到下载页面。 创建Sencha iOS项目 SDk下载好了之后就可以通过PhoneGap或者直接自己建个项目在webView里面加载Sencha页面就可以了。事实上还有第三种方法，就是Sencha Cmd，官方对Sencha Cmd的介绍是： Sencha Cmd is a cross-platform command line tool that provides many automated tasks around the full life-cycle of your applications, from generating a new project to deploying an application to production. 也就是说，我们可以直接使用Sencha Cmd这个工具进行全生命周期的应用开发。另外，官网还有个Sencha SDK Tools，不过官网也建议： Please note: Sencha SDK Tools are designed to be used with Sencha Touch 2 and Ext JS 4.0 and are deprecated for the most current framework releases. For the current version of Sencha’s build tools, please refer to Sencha Cmd, our unified tool for Sencha’s JavaScript frameworks. 所以还是老老实实下载Sencha Cmd吧，Sencha Cmd 下载地址。 下载后安装好就可以打开终端敲命令进行创建Sencha项目了，我们把项目创建在桌面，项目名称为HelloSencha，命令如下： $ sencha generate app HelloSenCha ~/Desktop/HelloSenCha Sencha Cmd v3.0.0.250 [INF] init-properties: [INF] init-sencha-command: [INF] init: [INF] -before-generate-workspace: [INF] generate-workspace-impl: [WRN] Ignoring @require ../version/Version.js in js/String.js [WRN] Ignoring @require ../Ext-more.js in js/Format.js [INF] -before-copy-framework-to-workspace: [INF] copy-framework-to-workspace-impl: 等命令执行完毕后，到桌面就可以看到创建好的项目了。 编译项目 无需通过Xcode，我们就可以直接执行命令进行编译，编译结果将放在../build 文件夹下。 $ sencha package build ~/Desktop/HelloSenCha/packager.json 运行项目 同样，我们无需打开Xcode，直接通过命令就可以把我们刚才创建的项目在iOS模拟器里面运行起来： $ sencha package run ~/Desktop/HelloSenCha/packager.json 现在，我们已经知道了怎么创建、编译和部署项目了，接下来就可以进行Sencha Touch SDK的学习了。 ","link":"https://blog.xioayee.top/post/shi-yong-sencha-touch-21-jin-xing-ios-kai-fa-kai-fa-huan-jing-da-jian/"},{"title":"更改navigationController push和pop界面切换动画","content":"有时候我们需要自定义navigationController push和pop界面切换动画，用到的代码如下： For Push: MainView *nextView=[[MainView alloc] init]; [UIView beginAnimations:nil context:NULL]; [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut]; [UIView setAnimationDuration:0.75]; [self.navigationController pushViewController:nextView animated:NO]; [UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:self.navigationController.view cache:NO]; [UIView commitAnimations]; [nextView release]; For Pop: 方法一： [UIView beginAnimations:nil context:NULL]; [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut]; [UIView setAnimationDuration:0.75]; [UIView setAnimationTransition:UIViewAnimationTransitionFlipFromLeft forView:self.navigationController.view cache:NO]; [UIView commitAnimations]; [UIView beginAnimations:nil context:NULL]; [UIView setAnimationDelay:0.375]; [self.navigationController popViewControllerAnimated:NO]; [UIView commitAnimations]; 方法二： 可实现左右滑动动画，可设置滑动方向。 CATransition* transition = [CATransition animation]; transition.duration = 0.5; transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; transition.type = kCATransitionFade; //kCATransitionMoveIn; //, kCATransitionPush, kCATransitionReveal, kCATransitionFade //transition.subtype = kCATransitionFromTop; //kCATransitionFromLeft, kCATransitionFromRight, kCATransitionFromTop, kCATransitionFromBottom [self.navigationController.view.layer addAnimation:transition forKey:nil]; [[self navigationController] popViewControllerAnimated:NO]; 具体的动画参数请自行更改。 ","link":"https://blog.xioayee.top/post/geng-gai-navigationcontroller-push-he-pop-jie-mian-qie-huan-dong-hua/"},{"title":"@class vs. #import，两种方式的讨论","content":"很多刚开始学习iOS开发的同学可能在看别人的代码的时候会发现有部分#import操作写在m文件中，而h文件仅仅使用@class进行声明，不禁纳闷起来，为什么不直接把#import放到h文件中呢？ 这是因为h文件在修改后，所有import该h文件的所有文件必须重新build，因此，如果把#import写在h文件中，import该h文件的文件也就会产生不必要的编译，增加编译时间，特别是在项目文件多的情况下。想象一下，如果只是修改一个h文件而导致上百个文件不必要的编译，那是一件多么让人纠结的事情。。。 对于@class只是告诉编译器有这个class，请不要报错或警告，因此不会给编译造成影响。 什么时候用@class这种方式声明比#import好呢？ stackoverflow上的高手们给了不少建议： Randy Marsh： When I develop, I have only three things in mind that never cause me any problems. Import super classes Import parent classes (when you have children and parents) Import classes outside your project (like in frameworks and libraries) For all other classes (subclasses and child classes in my project self), I declare them via forward-class. Justin： Simple answer: You #import or #include when there is a physical dependency. Otherwise, you use forward declarations (@class MONClass,struct MONStruct, @protocol MONProtocol). Here are some common examples of physical dependence: Any C or C++ value (a pointer or reference is not a physical dependency). If you have aCGPoint as an ivar or property, the compiler will need to see the declaration ofCGPoint. Your superclass. A method you use. 最后，我建议还是养成良好的import习惯，不要偷懒都把import放在h文件中，无论参与的项目大小，养成良好的编程习惯非常重要。 ","link":"https://blog.xioayee.top/post/class-vs-importliang-chong-fang-shi-de-tao-lun/"},{"title":"几个微博的同步——登录","content":"最近做了个微博软件，可以直接通过软件发微博，用了一段时间后，开通了腾讯微博，于是想把之前的微博内容也同步到腾讯微博上。马上用firebug分析了一下腾讯微博的登录过程，果然发现腾讯又对发送的qq密码进行加密，所以，要想顺利登录腾讯微博，第一步要做的就是要加密算法拿到手。 既然发送qq密码之前已经进行了加密，那加密肯定是在客户端进行的，于是我直接用firebug在相关js里面进行搜索，很快就定位到了加密算法的js文件，在该js文件可以找到对qq密码进行加密的代码： if (E[A].name == &quot;p&quot;) { var F = &quot;&quot;; F += E.verifycode.value; F = F.toUpperCase(); B += md5(md5_3(E.p.value) + F) } else { if (E[A].name == &quot;u1&quot; || E[A].name == &quot;ep&quot;) { B += encodeURIComponent(E[A].value) } else { B += E[A].value } } 分析了一下加密主要是这部分：B += md5(md5_3(E.p.value) + F)，E.p.value就是输入的密码，B是发送的参数，F是获取到的验证码。知道了加密过程，接下来的就好办了。直接用MSScriptControl来调用md5和md5_3函数对qq密码进行加密并且发送，当然在此之前比较先获取验证码。 对qq密码加密后，接着就直接根据firebug的分析，把相关数据进行发送就可以了，在发送之前需要注意的是记得要先获取并保存到相关的cookie，不然也会提示参数错误。 其实登录还有一个方法，就是通过webBrowser控件，直接定位到腾讯微博的登录窗口，在此之前开了qq的话就直接可以按快速登录进行登录了，然后通过webBrowser直接获取登录后的cookie就可以了。 ","link":"https://blog.xioayee.top/post/ji-ge-wei-bo-de-tong-bu-deng-lu/"}]}