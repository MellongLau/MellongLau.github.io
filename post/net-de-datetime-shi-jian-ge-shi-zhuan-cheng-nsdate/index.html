<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>.net的DateTime时间格式转成NSDate | Mellong的技术博客</title>

<link rel="shortcut icon" href="https://blog.xioayee.top/favicon.ico?v=1713096817003">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://blog.xioayee.top/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Mellong的技术博客
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1713096817003" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    .net的DateTime时间格式转成NSDate
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2013-04-10 ·
                    </time>
                    
                        <a href="https://blog.xioayee.top/tag/ZtKpOTEdb/" class="post-tags">
                            # iOS
                        </a>
                    
                </div>
                <div class="post-content">
                    <p>最近项目中用到的接口是.net写的，传过来的日期格式是 2013-04-10T10:36:48.787359+08:00 , 这么一大串想解析成NSDate格式还真不是一件容易的事，幸好已经有人把转换类写出来了。</p>
<!-- more -->
<h2 id="转换类">转换类</h2>
<p>老外写的转换类，地址不记得了，直接上代码</p>
<pre><code class="language-objc">     /*ISO8601DateFormatter.h
     *
     *Created by Peter Hosey on 2009-04-11.
     *Copyright 2009 Peter Hosey. All rights reserved.
     */
    
    #import &lt;Foundation/Foundation.h&gt;
    
    /*This class converts dates to and from ISO 8601 strings. A good introduction to ISO 8601: &lt;http://www.cl.cam.ac.uk/~mgk25/iso-time.html&gt;
     *
     *Parsing can be done strictly, or not. When you parse loosely, leading whitespace is ignored, as is anything after the date.
     *The loose parser will return an NSDate for this string: @&quot; \t\r\n\f\t  2006-03-02!!!&quot;
     *Leading non-whitespace will not be ignored; the string will be rejected, and nil returned. See the README that came with this addition.
     *
     *The strict parser will only accept a string if the date is the entire string. The above string would be rejected immediately, solely on these grounds.
     *Also, the loose parser provides some extensions that the strict parser doesn't.
     *For example, the standard says for &quot;-DDD&quot; (an ordinal date in the implied year) that the logical representation (meaning, hierarchically) would be &quot;--DDD&quot;, but because that extra hyphen is &quot;superfluous&quot;, it was omitted.
     *The loose parser will accept the extra hyphen; the strict parser will not.
     *A full list of these extensions is in the README file.
     */
    
    /*The format to either expect or produce.
     *Calendar format is YYYY-MM-DD.
     *Ordinal format is YYYY-DDD, where DDD ranges from 1 to 366; for example, 2009-32 is 2009-02-01.
     *Week format is YYYY-Www-D, where ww ranges from 1 to 53 (the 'W' is literal) and D ranges from 1 to 7; for example, 2009-W05-07.
     */
    enum {
        ISO8601DateFormatCalendar,
        ISO8601DateFormatOrdinal,
        ISO8601DateFormatWeek,
    };
    typedef NSUInteger ISO8601DateFormat;
    
    //The default separator for time values. Currently, this is ':'.
    extern unichar ISO8601DefaultTimeSeparatorCharacter;
    
    @interface ISO8601DateFormatter: NSFormatter
    {
        NSString *lastUsedFormatString;
        NSDateFormatter *unparsingFormatter;
        
        NSCalendar *parsingCalendar, *unparsingCalendar;
        
        NSTimeZone *defaultTimeZone;
        ISO8601DateFormat format;
        unichar timeSeparator;
        BOOL includeTime;
        BOOL parsesStrictly;
    }
    
    //Call this if you get a memory warning.
    + (void) purgeGlobalCaches;
    
    @property(nonatomic, retain) NSTimeZone *defaultTimeZone;
    
    #pragma mark Parsing
    
    //As a formatter, this object converts strings to dates.
    
    @property BOOL parsesStrictly;
    
    - (NSDateComponents *) dateComponentsFromString:(NSString *)string;
    - (NSDateComponents *) dateComponentsFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone;
    - (NSDateComponents *) dateComponentsFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone range:(out NSRange *)outRange;
    
    - (NSDate *) dateFromString:(NSString *)string;
    - (NSDate *) dateFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone;
    - (NSDate *) dateFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone range:(out NSRange *)outRange;
    
    #pragma mark Unparsing
    
    @property ISO8601DateFormat format;
    @property BOOL includeTime;
    @property unichar timeSeparator;
    
    - (NSString *) stringFromDate:(NSDate *)date;
    - (NSString *) stringFromDate:(NSDate *)date timeZone:(NSTimeZone *)timeZone;
    
    @end
    


    /*ISO8601DateFormatter.m
     *
     *Created by Peter Hosey on 2009-04-11.
     *Copyright 2009 Peter Hosey. All rights reserved.
     */
    
    #import &lt;Foundation/Foundation.h&gt;
    #import &quot;ISO8601DateFormatter.h&quot;
    
    #ifndef DEFAULT_TIME_SEPARATOR
    #       define DEFAULT_TIME_SEPARATOR ':'
    #endif
    unichar ISO8601DefaultTimeSeparatorCharacter = DEFAULT_TIME_SEPARATOR;
    
    //Unicode date formats.
    #define ISO_CALENDAR_DATE_FORMAT @&quot;yyyy-MM-dd&quot;
    //#define ISO_WEEK_DATE_FORMAT @&quot;YYYY-'W'ww-ee&quot; //Doesn't actually work because NSDateComponents counts the weekday starting at 1.
    #define ISO_ORDINAL_DATE_FORMAT @&quot;yyyy-DDD&quot;
    #define ISO_TIME_FORMAT @&quot;HH:mm:ss&quot;
    #define ISO_TIME_WITH_TIMEZONE_FORMAT  ISO_TIME_FORMAT @&quot;Z&quot;
    //printf formats.
    #define ISO_TIMEZONE_UTC_FORMAT @&quot;Z&quot;
    #define ISO_TIMEZONE_OFFSET_FORMAT @&quot;%+.2d%.2d&quot;
    
    @interface ISO8601DateFormatter(UnparsingPrivate)
    
    - (NSString *) replaceColonsInString:(NSString *)timeFormat withTimeSeparator:(unichar)timeSep;
    
    - (NSString *) stringFromDate:(NSDate *)date formatString:(NSString *)dateFormat timeZone:(NSTimeZone *)timeZone;
    - (NSString *) weekDateStringForDate:(NSDate *)date timeZone:(NSTimeZone *)timeZone;
    
    @end
    
    static NSMutableDictionary *timeZonesByOffset;
    
    @implementation ISO8601DateFormatter
    
    + (void) initialize {
        if (!timeZonesByOffset) {
            timeZonesByOffset = [[NSMutableDictionary alloc] init];
        }
    }
    
    + (void) purgeGlobalCaches {
        NSMutableDictionary *oldCache = timeZonesByOffset;
        timeZonesByOffset = nil;
        [oldCache release];
    }
    
    - (NSCalendar *) makeCalendarWithDesiredConfiguration {
        NSCalendar *calendar = [[[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar] autorelease];
        calendar.firstWeekday = 2; //Monday
        calendar.timeZone = [NSTimeZone defaultTimeZone];
        return calendar;
    }
    
    - (id) init {
        if ((self = [super init])) {
            parsingCalendar = [[self makeCalendarWithDesiredConfiguration] retain];
            unparsingCalendar = [[self makeCalendarWithDesiredConfiguration] retain];
            
            format = ISO8601DateFormatCalendar;
            timeSeparator = ISO8601DefaultTimeSeparatorCharacter;
            includeTime = NO;
            parsesStrictly = NO;
        }
        return self;
    }
    - (void) dealloc {
        [defaultTimeZone release];
        
        [unparsingFormatter release];
        [lastUsedFormatString release];
        [parsingCalendar release];
        [unparsingCalendar release];
        
        [super dealloc];
    }
    
    @synthesize defaultTimeZone;
    - (void) setDefaultTimeZone:(NSTimeZone *)tz {
        if (defaultTimeZone != tz) {
            [defaultTimeZone release];
            defaultTimeZone = [tz retain];
            
            unparsingCalendar.timeZone = defaultTimeZone;
        }
    }
    
    //The following properties are only here because GCC doesn't like @synthesize in category implementations.
    
    #pragma mark Parsing
    
    @synthesize parsesStrictly;
    
    static NSUInteger read_segment(const unsigned char *str, const unsigned char **next, NSUInteger *out_num_digits);
    static NSUInteger read_segment_4digits(const unsigned char *str, const unsigned char **next, NSUInteger *out_num_digits);
    static NSUInteger read_segment_2digits(const unsigned char *str, const unsigned char **next);
    static double read_double(const unsigned char *str, const unsigned char **next);
    static BOOL is_leap_year(NSUInteger year);
    
    /*Valid ISO 8601 date formats:
     *
     *YYYYMMDD
     *YYYY-MM-DD
     *YYYY-MM
     *YYYY
     *YY //century
     * //Implied century: YY is 00-99
     *  YYMMDD
     *  YY-MM-DD
     * -YYMM
     * -YY-MM
     * -YY
     * //Implied year
     *  --MMDD
     *  --MM-DD
     *  --MM
     * //Implied year and month
     *   ---DD
     * //Ordinal dates: DDD is the number of the day in the year (1-366)
     *YYYYDDD
     *YYYY-DDD
     *  YYDDD
     *  YY-DDD
     *   -DDD
     * //Week-based dates: ww is the number of the week, and d is the number (1-7) of the day in the week
     *yyyyWwwd
     *yyyy-Www-d
     *yyyyWww
     *yyyy-Www
     *yyWwwd
     *yy-Www-d
     *yyWww
     *yy-Www
     * //Year of the implied decade
     *-yWwwd
     *-y-Www-d
     *-yWww
     *-y-Www
     * //Week and day of implied year
     *  -Wwwd
     *  -Www-d
     * //Week only of implied year
     *  -Www
     * //Day only of implied week
     *  -W-d
     */
    
    - (NSDateComponents *) dateComponentsFromString:(NSString *)string {
        return [self dateComponentsFromString:string timeZone:NULL];
    }
    - (NSDateComponents *) dateComponentsFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone {
        return [self dateComponentsFromString:string timeZone:outTimeZone range:NULL];
    }
    - (NSDateComponents *) dateComponentsFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone range:(out NSRange *)outRange {
        NSDate *now = [NSDate date];
        
        NSDateComponents *components = [[[NSDateComponents alloc] init] autorelease];
        NSDateComponents *nowComponents = [parsingCalendar components:(NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit) fromDate:now];
        
        NSUInteger
        //Date
        year,
        month_or_week = 0U,
        day = 0U,
        //Time
        hour = 0U;
        NSTimeInterval
        minute = 0.0,
        second = 0.0;
        //Time zone
        NSInteger tz_hour = 0;
        NSInteger tz_minute = 0;
        
        enum {
            monthAndDate,
            week,
            dateOnly
        } dateSpecification = monthAndDate;
        
        BOOL strict = self.parsesStrictly;
        unichar timeSep = self.timeSeparator;
        
        if (strict) timeSep = ISO8601DefaultTimeSeparatorCharacter;
        NSAssert(timeSep != '\0', @&quot;Time separator must not be NUL.&quot;);
        
        BOOL isValidDate = ([string length] &gt; 0U);
        NSTimeZone *timeZone = nil;
        
        const unsigned char *ch = (const unsigned char *)[string UTF8String];
        
        NSRange range = { 0U, 0U };
        const unsigned char *start_of_date = NULL;
        if (strict &amp;&amp; isspace(*ch)) {
            range.location = NSNotFound;
            isValidDate = NO;
        } else {
            //Skip leading whitespace.
            NSUInteger i = 0U;
            for(NSUInteger len = strlen((const char *)ch); i &lt; len; ++i) {
                if (!isspace(ch[i]))
                    break;
            }
            
            range.location = i;
            ch += i;
            start_of_date = ch;
            
            NSUInteger segment;
            NSUInteger num_leading_hyphens = 0U, num_digits = 0U;
            
            if (*ch == 'T') {
                //There is no date here, only a time. Set the date to now; then we'll parse the time.
                isValidDate = isdigit(*++ch);
                
                year = nowComponents.year;
                month_or_week = nowComponents.month;
                day = nowComponents.day;
            } else {
                while(*ch == '-') {
                    ++num_leading_hyphens;
                    ++ch;
                }
                
                segment = read_segment(ch, &amp;ch, &amp;num_digits);
                switch(num_digits) {
                    case 0:
                        if (*ch == 'W') {
                            if ((ch[1] == '-') &amp;&amp; isdigit(ch[2]) &amp;&amp; ((num_leading_hyphens == 1U) || ((num_leading_hyphens == 2U) &amp;&amp; !strict))) {
                                year = nowComponents.year;
                                month_or_week = 1U;
                                ch += 2;
                                goto parseDayAfterWeek;
                            } else if (num_leading_hyphens == 1U) {
                                year = nowComponents.year;
                                goto parseWeekAndDay;
                            } else
                                isValidDate = NO;
                        } else
                            isValidDate = NO;
                        break;
                        
                    case 8: //YYYY MM DD
                        if (num_leading_hyphens &gt; 0U)
                            isValidDate = NO;
                        else {
                            day = segment % 100U;
                            segment /= 100U;
                            month_or_week = segment % 100U;
                            year = segment / 100U;
                        }
                        break;
                        
                    case 6: //YYMMDD (implicit century)
                        if (num_leading_hyphens &gt; 0U)
                            isValidDate = NO;
                        else {
                            day = segment % 100U;
                            segment /= 100U;
                            month_or_week = segment % 100U;
                            year  = nowComponents.year;
                            year -= (year % 100U);
                            year += segment / 100U;
                        }
                        break;
                        
                    case 4:
                        switch(num_leading_hyphens) {
                            case 0: //YYYY
                                year = segment;
                                
                                if (*ch == '-') ++ch;
                                
                                if (!isdigit(*ch)) {
                                    if (*ch == 'W')
                                        goto parseWeekAndDay;
                                    else
                                        month_or_week = day = 1U;
                                } else {
                                    segment = read_segment(ch, &amp;ch, &amp;num_digits);
                                    switch(num_digits) {
                                        case 4: //MMDD
                                            day = segment % 100U;
                                            month_or_week = segment / 100U;
                                            break;
                                            
                                        case 2: //MM
                                            month_or_week = segment;
                                            
                                            if (*ch == '-') ++ch;
                                            if (!isdigit(*ch))
                                                day = 1U;
                                            else
                                                day = read_segment(ch, &amp;ch, NULL);
                                            break;
                                            
                                        case 3: //DDD
                                            day = segment % 1000U;
                                            dateSpecification = dateOnly;
                                            if (strict &amp;&amp; (day &gt; (365U + is_leap_year(year))))
                                                isValidDate = NO;
                                            break;
                                            
                                        default:
                                            isValidDate = NO;
                                    }
                                }
                                break;
                                
                            case 1: //YYMM
                                month_or_week = segment % 100U;
                                year = segment / 100U;
                                
                                if (*ch == '-') ++ch;
                                if (!isdigit(*ch))
                                    day = 1U;
                                else
                                    day = read_segment(ch, &amp;ch, NULL);
                                
                                break;
                                
                            case 2: //MMDD
                                day = segment % 100U;
                                month_or_week = segment / 100U;
                                year = nowComponents.year;
                                
                                break;
                                
                            default:
                                isValidDate = NO;
                        } //switch(num_leading_hyphens) (4 digits)
                        break;
                        
                    case 1:
                        if (strict) {
                            //Two digits only - never just one.
                            if (num_leading_hyphens == 1U) {
                                if (*ch == '-') ++ch;
                                if (*++ch == 'W') {
                                    year  = nowComponents.year;
                                    year -= (year % 10U);
                                    year += segment;
                                    goto parseWeekAndDay;
                                } else
                                    isValidDate = NO;
                            } else
                                isValidDate = NO;
                            break;
                        }
                    case 2:
                        switch(num_leading_hyphens) {
                            case 0:
                                if (*ch == '-') {
                                    //Implicit century
                                    year  = nowComponents.year;
                                    year -= (year % 100U);
                                    year += segment;
                                    
                                    if (*++ch == 'W')
                                        goto parseWeekAndDay;
                                    else if (!isdigit(*ch)) {
                                        goto centuryOnly;
                                    } else {
                                        //Get month and/or date.
                                        segment = read_segment_4digits(ch, &amp;ch, &amp;num_digits);
                                        NSLog(@&quot;(%@) parsing month; segment is %lu and ch is %s&quot;, string, (unsigned long)segment, ch);
                                        switch(num_digits) {
                                            case 4: //YY-MMDD
                                                day = segment % 100U;
                                                month_or_week = segment / 100U;
                                                break;
                                                
                                            case 1: //YY-M; YY-M-DD (extension)
                                                if (strict) {
                                                    isValidDate = NO;
                                                    break;
                                                }
                                            case 2: //YY-MM; YY-MM-DD
                                                month_or_week = segment;
                                                if (*ch == '-') {
                                                    if (isdigit(*++ch))
                                                        day = read_segment_2digits(ch, &amp;ch);
                                                    else
                                                        day = 1U;
                                                } else
                                                    day = 1U;
                                                break;
                                                
                                            case 3: //Ordinal date.
                                                day = segment;
                                                dateSpecification = dateOnly;
                                                break;
                                        }
                                    }
                                } else if (*ch == 'W') {
                                    year  = nowComponents.year;
                                    year -= (year % 100U);
                                    year += segment;
                                    
                                parseWeekAndDay: //*ch should be 'W' here.
                                    if (!isdigit(*++ch)) {
                                        //Not really a week-based date; just a year followed by '-W'.
                                        if (strict)
                                            isValidDate = NO;
                                        else
                                            month_or_week = day = 1U;
                                    } else {
                                        month_or_week = read_segment_2digits(ch, &amp;ch);
                                        if (*ch == '-') ++ch;
                                    parseDayAfterWeek:
                                        day = isdigit(*ch) ? read_segment_2digits(ch, &amp;ch) : 1U;
                                        dateSpecification = week;
                                    }
                                } else {
                                    //Century only. Assume current year.
                                centuryOnly:
                                    year = segment * 100U + nowComponents.year % 100U;
                                    month_or_week = day = 1U;
                                }
                                break;
                                
                            case 1:; //-YY; -YY-MM (implicit century)
                                NSLog(@&quot;(%@) found %lu digits and one hyphen, so this is either -YY or -YY-MM; segment (year) is %lu&quot;, string, (unsigned long)num_digits, (unsigned long)segment);
                                NSUInteger current_year = nowComponents.year;
                                NSUInteger current_century = (current_year % 100U);
                                year = segment + (current_year - current_century);
                                if (num_digits == 1U) //implied decade
                                    year += current_century - (current_year % 10U);
                                
                                if (*ch == '-') {
                                    ++ch;
                                    month_or_week = read_segment_2digits(ch, &amp;ch);
                                    NSLog(@&quot;(%@) month is %lu&quot;, string, (unsigned long)month_or_week);
                                }
                                
                                day = 1U;
                                break;
                                
                            case 2: //--MM; --MM-DD
                                year = nowComponents.year;
                                month_or_week = segment;
                                if (*ch == '-') {
                                    ++ch;
                                    day = read_segment_2digits(ch, &amp;ch);
                                }
                                break;
                                
                            case 3: //---DD
                                year = nowComponents.year;
                                month_or_week = nowComponents.month;
                                day = segment;
                                break;
                                
                            default:
                                isValidDate = NO;
                        } //switch(num_leading_hyphens) (2 digits)
                        break;
                        
                    case 7: //YYYY DDD (ordinal date)
                        if (num_leading_hyphens &gt; 0U)
                            isValidDate = NO;
                        else {
                            day = segment % 1000U;
                            year = segment / 1000U;
                            dateSpecification = dateOnly;
                            if (strict &amp;&amp; (day &gt; (365U + is_leap_year(year))))
                                isValidDate = NO;
                        }
                        break;
                        
                    case 3: //--DDD (ordinal date, implicit year)
                        //Technically, the standard only allows one hyphen. But it says that two hyphens is the logical implementation, and one was dropped for brevity. So I have chosen to allow the missing hyphen.
                        if ((num_leading_hyphens &lt; 1U) || ((num_leading_hyphens &gt; 2U) &amp;&amp; !strict))
                            isValidDate = NO;
                        else {
                            day = segment;
                            year = nowComponents.year;
                            dateSpecification = dateOnly;
                            if (strict &amp;&amp; (day &gt; (365U + is_leap_year(year))))
                                isValidDate = NO;
                        }
                        break;
                        
                    default:
                        isValidDate = NO;
                }
            }
            
            if (isValidDate) {
                if (isspace(*ch) || (*ch == 'T')) ++ch;
                
                if (isdigit(*ch)) {
                    hour = read_segment_2digits(ch, &amp;ch);
                    if (*ch == timeSep) {
                        ++ch;
                        if ((timeSep == ',') || (timeSep == '.')) {
                            //We can't do fractional minutes when '.' is the segment separator.
                            //Only allow whole minutes and whole seconds.
                            minute = read_segment_2digits(ch, &amp;ch);
                            if (*ch == timeSep) {
                                ++ch;
                                second = read_segment_2digits(ch, &amp;ch);
                            }
                        } else {
                            //Allow a fractional minute.
                            //If we don't get a fraction, look for a seconds segment.
                            //Otherwise, the fraction of a minute is the seconds.
                            minute = read_double(ch, &amp;ch);
                            second = modf(minute, &amp;minute);
                            if (second &gt; DBL_EPSILON)
                                second *= 60.0; //Convert fraction (e.g. .5) into seconds (e.g. 30).
                            else if (*ch == timeSep) {
                                ++ch;
                                second = read_double(ch, &amp;ch);
                            }
                        }
                    }
                    
                    if (!strict) {
                        if (isspace(*ch)) ++ch;
                    }
                    
                    switch(*ch) {
                        case 'Z':
                            timeZone = [NSTimeZone timeZoneWithAbbreviation:@&quot;UTC&quot;];
                            break;
                            
                        case '+':
                        case '-':;
                            BOOL negative = (*ch == '-');
                            if (isdigit(*++ch)) {
                                //Read hour offset.
                                segment = *ch - '0';
                                if (isdigit(*++ch)) {
                                    segment *= 10U;
                                    segment += *(ch++) - '0';
                                }
                                tz_hour = (NSInteger)segment;
                                if (negative) tz_hour = -tz_hour;
                                
                                //Optional separator.
                                if (*ch == timeSep) ++ch;
                                
                                if (isdigit(*ch)) {
                                    //Read minute offset.
                                    segment = *ch - '0';
                                    if (isdigit(*++ch)) {
                                        segment *= 10U;
                                        segment += *ch - '0';
                                    }
                                    tz_minute = segment;
                                    if (negative) tz_minute = -tz_minute;
                                }
                                
                                NSInteger timeZoneOffset = (tz_hour * 3600) + (tz_minute * 60);
                                NSNumber *offsetNum = [NSNumber numberWithInteger:timeZoneOffset];
                                timeZone = [timeZonesByOffset objectForKey:offsetNum];
                                if (!timeZone) {
                                    timeZone = [NSTimeZone timeZoneForSecondsFromGMT:timeZoneOffset];
                                    if (timeZone)
                                        [timeZonesByOffset setObject:timeZone forKey:offsetNum];
                                }
                            }
                    }
                }
            }
            
            if (isValidDate) {
                components.year = year;
                components.day = day;
                components.hour = hour;
                components.minute = (NSInteger)minute;
                components.second = (NSInteger)second;
                
                switch(dateSpecification) {
                    case monthAndDate:
                        components.month = month_or_week;
                        break;
                        
                    case week:;
                        //Adapted from &lt;http://personal.ecu.edu/mccartyr/ISOwdALG.txt&gt;.
                        //This works by converting the week date into an ordinal date, then letting the next case handle it.
                        NSUInteger prevYear = year - 1U;
                        NSUInteger YY = prevYear % 100U;
                        NSUInteger C = prevYear - YY;
                        NSUInteger G = YY + YY / 4U;
                        NSUInteger isLeapYear = (((C / 100U) % 4U) * 5U);
                        NSUInteger Jan1Weekday = (isLeapYear + G) % 7U;
                        enum { monday, tuesday, wednesday, thursday/*, friday, saturday, sunday*/ };
                        components.day = ((8U - Jan1Weekday) + (7U * (Jan1Weekday &gt; thursday))) + (day - 1U) + (7U * (month_or_week - 2));
                        
                    case dateOnly: //An &quot;ordinal date&quot;.
                        break;
                }
            }
        } //if (!(strict &amp;&amp; isdigit(ch[0])))
        
        if (outRange) {
            if (isValidDate)
                range.length = ch - start_of_date;
            else
                range.location = NSNotFound;
            
            *outRange = range;
        }
        if (outTimeZone) {
            *outTimeZone = timeZone;
        }
        
        return components;
    }
    
    - (NSDate *) dateFromString:(NSString *)string {
        return [self dateFromString:string timeZone:NULL];
    }
    - (NSDate *) dateFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone {
        return [self dateFromString:string timeZone:outTimeZone range:NULL];
    }
    - (NSDate *) dateFromString:(NSString *)string timeZone:(out NSTimeZone **)outTimeZone range:(out NSRange *)outRange {
        NSTimeZone *timeZone = nil;
        NSDateComponents *components = [self dateComponentsFromString:string timeZone:&amp;timeZone range:outRange];
        if (outTimeZone)
            *outTimeZone = timeZone;
        parsingCalendar.timeZone = timeZone;
        
        return [parsingCalendar dateFromComponents:components];
    }
    
    - (BOOL)getObjectValue:(id *)outValue forString:(NSString *)string errorDescription:(NSString **)error {
        NSDate *date = [self dateFromString:string];
        if (outValue)
            *outValue = date;
        return (date != nil);
    }
    
    #pragma mark Unparsing
    
    @synthesize format;
    @synthesize includeTime;
    @synthesize timeSeparator;
    
    - (NSString *) replaceColonsInString:(NSString *)timeFormat withTimeSeparator:(unichar)timeSep {
        if (timeSep != ':') {
            NSMutableString *timeFormatMutable = [[timeFormat mutableCopy] autorelease];
            [timeFormatMutable replaceOccurrencesOfString:@&quot;:&quot;
                                               withString:[NSString stringWithCharacters:&amp;timeSep length:1U]
                                                  options:NSBackwardsSearch | NSLiteralSearch
                                                    range:(NSRange){ 0UL, [timeFormat length] }];
            timeFormat = timeFormatMutable;
        }
        return timeFormat;
    }
    
    - (NSString *) stringFromDate:(NSDate *)date {
        NSTimeZone *timeZone = self.defaultTimeZone;
        if (!timeZone) timeZone = [NSTimeZone defaultTimeZone];
        return [self stringFromDate:date timeZone:timeZone];
    }
    
    - (NSString *) stringFromDate:(NSDate *)date timeZone:(NSTimeZone *)timeZone {
        switch (self.format) {
            case ISO8601DateFormatCalendar:
                return [self stringFromDate:date formatString:ISO_CALENDAR_DATE_FORMAT timeZone:timeZone];
            case ISO8601DateFormatWeek:
                return [self weekDateStringForDate:date timeZone:timeZone];
            case ISO8601DateFormatOrdinal:
                return [self stringFromDate:date formatString:ISO_ORDINAL_DATE_FORMAT timeZone:timeZone];
            default:
                [NSException raise:NSInternalInconsistencyException format:@&quot;self.format was %d, not calendar (%d), week (%d), or ordinal (%d)&quot;, self.format, ISO8601DateFormatCalendar, ISO8601DateFormatWeek, ISO8601DateFormatOrdinal];
                return nil;
        }
    }
    
    - (NSString *) stringFromDate:(NSDate *)date formatString:(NSString *)dateFormat timeZone:(NSTimeZone *)timeZone {
        if (includeTime)
            dateFormat = [dateFormat stringByAppendingFormat:@&quot;'T'%@&quot;, [self replaceColonsInString:ISO_TIME_FORMAT withTimeSeparator:self.timeSeparator]];
        
        unparsingCalendar.timeZone = timeZone;
        
        if (dateFormat != lastUsedFormatString) {
            [unparsingFormatter release];
            unparsingFormatter = nil;
            
            [lastUsedFormatString release];
            lastUsedFormatString = [dateFormat retain];
        }
        
        if (!unparsingFormatter) {
            unparsingFormatter = [[NSDateFormatter alloc] init];
            unparsingFormatter.formatterBehavior = NSDateFormatterBehavior10_4;
            unparsingFormatter.dateFormat = dateFormat;
            unparsingFormatter.calendar = unparsingCalendar;
        }
        
        NSString *str = [unparsingFormatter stringForObjectValue:date];
        
        if (includeTime) {
            NSInteger offset = [timeZone secondsFromGMT];
            offset /= 60;  //bring down to minutes
            if (offset == 0)
                str = [str stringByAppendingString:ISO_TIMEZONE_UTC_FORMAT];
            else
                str = [str stringByAppendingFormat:ISO_TIMEZONE_OFFSET_FORMAT, offset / 60, offset % 60];
        }
        
        //Undo the change we made earlier
        unparsingCalendar.timeZone = self.defaultTimeZone;
        
        return str;
    }
    
    - (NSString *) stringForObjectValue:(id)value {
        NSParameterAssert([value isKindOfClass:[NSDate class]]);
        
        return [self stringFromDate:(NSDate *)value];
    }
    
    /*Adapted from:
     *      Algorithm for Converting Gregorian Dates to ISO 8601 Week Date
     *      Rick McCarty, 1999
     *      http://personal.ecu.edu/mccartyr/ISOwdALG.txt
     */
    - (NSString *) weekDateStringForDate:(NSDate *)date timeZone:(NSTimeZone *)timeZone {
        unparsingCalendar.timeZone = timeZone;
        NSDateComponents *components = [unparsingCalendar components:NSYearCalendarUnit | NSWeekdayCalendarUnit | NSDayCalendarUnit fromDate:date];
        
        //Determine the ordinal date.
        NSDateComponents *startOfYearComponents = [unparsingCalendar components:NSYearCalendarUnit fromDate:date];
        startOfYearComponents.month = 1;
        startOfYearComponents.day = 1;
        NSDateComponents *ordinalComponents = [unparsingCalendar components:NSDayCalendarUnit fromDate:[unparsingCalendar dateFromComponents:startOfYearComponents] toDate:date options:0];
        ordinalComponents.day += 1;
        
        enum {
            monday, tuesday, wednesday, thursday, friday, saturday, sunday
        };
        enum {
            january = 1, february, march,
            april, may, june,
            july, august, september,
            october, november, december
        };
        
        NSInteger year = components.year;
        NSInteger week = 0;
        //The old unparser added 6 to [calendarDate dayOfWeek], which was zero-based; components.weekday is one-based, so we now add only 5.
        NSInteger dayOfWeek = (components.weekday + 5) % 7;
        NSInteger dayOfYear = ordinalComponents.day;
        
        NSInteger prevYear = year - 1;
        
        BOOL yearIsLeapYear = is_leap_year(year);
        BOOL prevYearIsLeapYear = is_leap_year(prevYear);
        
        NSInteger YY = prevYear % 100;
        NSInteger C = prevYear - YY;
        NSInteger G = YY + YY / 4;
        NSInteger Jan1Weekday = (((((C / 100) % 4) * 5) + G) % 7);
        
        NSInteger weekday = ((dayOfYear + Jan1Weekday) - 1) % 7;
        
        if((dayOfYear &lt;= (7 - Jan1Weekday)) &amp;&amp; (Jan1Weekday &gt; thursday)) {
            week = 52 + ((Jan1Weekday == friday) || ((Jan1Weekday == saturday) &amp;&amp; prevYearIsLeapYear));
            --year;
        } else {
            NSInteger lengthOfYear = 365 + yearIsLeapYear;
            if((lengthOfYear - dayOfYear) &lt; (thursday - weekday)) {
                ++year;
                week = 1;
            } else {
                NSInteger J = dayOfYear + (sunday - weekday) + Jan1Weekday;
                week = J / 7 - (Jan1Weekday &gt; thursday);
            }
        }
        
        NSString *timeString;
        if(includeTime) {
            NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
            unichar timeSep = self.timeSeparator;
            if (!timeSep) timeSep = ISO8601DefaultTimeSeparatorCharacter;
            formatter.dateFormat = [self replaceColonsInString:ISO_TIME_WITH_TIMEZONE_FORMAT withTimeSeparator:timeSep];
            
            timeString = [formatter stringForObjectValue:date];
            
            [formatter release];
        } else
            timeString = @&quot;&quot;;
        
        return [NSString stringWithFormat:@&quot;%lu-W%02lu-%02lu%@&quot;, (unsigned long)year, (unsigned long)week, ((unsigned long)dayOfWeek) + 1U, timeString];
    }
    
    @end
    
    static NSUInteger read_segment(const unsigned char *str, const unsigned char **next, NSUInteger *out_num_digits) {
        NSUInteger num_digits = 0U;
        NSUInteger value = 0U;
        
        while(isdigit(*str)) {
            value *= 10U;
            value += *str - '0';
            ++num_digits;
            ++str;
        }
        
        if (next) *next = str;
        if (out_num_digits) *out_num_digits = num_digits;
        
        return value;
    }
    static NSUInteger read_segment_4digits(const unsigned char *str, const unsigned char **next, NSUInteger *out_num_digits) {
        NSUInteger num_digits = 0U;
        NSUInteger value = 0U;
        
        if (isdigit(*str)) {
            value += *(str++) - '0';
            ++num_digits;
        }
        
        if (isdigit(*str)) {
            value *= 10U;
            value += *(str++) - '0';
            ++num_digits;
        }
        
        if (isdigit(*str)) {
            value *= 10U;
            value += *(str++) - '0';
            ++num_digits;
        }
        
        if (isdigit(*str)) {
            value *= 10U;
            value += *(str++) - '0';
            ++num_digits;
        }
        
        if (next) *next = str;
        if (out_num_digits) *out_num_digits = num_digits;
        
        return value;
    }
    static NSUInteger read_segment_2digits(const unsigned char *str, const unsigned char **next) {
        NSUInteger value = 0U;
        
        if (isdigit(*str))
            value += *str - '0';
        
        if (isdigit(*++str)) {
            value *= 10U;
            value += *(str++) - '0';
        }
        
        if (next) *next = str;
        
        return value;
    }
    
    //strtod doesn't support ',' as a separator. This does.
    static double read_double(const unsigned char *str, const unsigned char **next) {
        double value = 0.0;
        
        if (str) {
            NSUInteger int_value = 0;
            
            while(isdigit(*str)) {
                int_value *= 10U;
                int_value += (*(str++) - '0');
            }
            value = int_value;
            
            if (((*str == ',') || (*str == '.'))) {
                ++str;
                
                register double multiplier, multiplier_multiplier;
                multiplier = multiplier_multiplier = 0.1;
                
                while(isdigit(*str)) {
                    value += (*(str++) - '0') * multiplier;
                    multiplier *= multiplier_multiplier;
                }
            }
        }
        
        if (next) *next = str;
        
        return value;
    }
    
    static BOOL is_leap_year(NSUInteger year) {
        return \
        ((year %   4U) == 0U)
        &amp;&amp; (((year % 100U) != 0U)
            ||  ((year % 400U) == 0U));
  }
</code></pre>
<h2 id="用法">用法</h2>
<pre><code class="language-objc">	ISO8601DateFormatter *dateFormat = [[[ISO8601DateFormatter alloc] init] autorelease];
    NSDate *serverTime = [dateFormat dateFromString:dateTime];
</code></pre>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://blog.xioayee.top/post/shi-yong-sencha-touch-21-jin-xing-ios-kai-fa-xiang-mu-wen-jian-jie-gou-ji-dai-ma-fen-xi2/" class="post-title gt-a-link">
                    使用Sencha Touch 2.1进行iOS开发 —— 项目文件结构及代码分析
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">iOS开发，电子产品爱好者</div>
    <div class="social-container">
        
            
                <a href="https://github.com/MellongLau" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://blog.xioayee.top/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
